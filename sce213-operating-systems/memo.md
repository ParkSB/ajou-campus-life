# 운영체제

## Introduction to Operating Systems

### System Calls

- 폰 노이만 구조, 모드 얘기, privileged instructions.
- 인터럽트:
  - 인터럽트는 하드웨어 장치가 만드는 신호. 비동기적으로 발생.
  - 현대 컴퓨터는 인터럽트 주도 방식으로 동작. 인터럽트가 발생하면 모드가 전환될 수 있음.
  - 익셉션(exception):
    - 소프트웨어가 인스트럭션을 실행하다가 만드는 신호.
    - 동기적으로 발생. CPU가 인스트럭션을 실행할 때만 일어남.
    - 의도를 갖고 일으킨 익셉션은 트랩(trap).
    - 예상치 못한 익셉션은 폴트(fault)
- 시스템 콜:
  - 식당에서 벨 누르면 주방에서 커널모드로 일하던 사장님이 홀에 나와서 유저모드로 전환하심.
  - OS가 서비스에게 제공하는 프로그래밍 인터페이스:
    - Win32 API for Windows, POSIX API for POSIX-based systems, Java API for JVM 등.
    - OS가 제공하는 서비스는 프로그램 실행, 파일 시스템, IO, 통신, 에러 감지 등.
  - man 페이지에 다 나와있음. 궁금하면 그냥 무조건 man 페이지보세요.
  - 리눅스에 시스템 콜이 몇 개나 있을 것 같아요? 350개 정도.
  - 저는 시스템 콜 써본 적이 없는데용? 사실 다 쓰고 있음.
  - `printf`도 시스템 콜인가요? 그건 표준 C 라이브러리. 라이브러리가 `write` 시스템 콜을 호출함.
- 컴퓨터 켜면 무슨 일이 일어나나요? Bootstrap program > Bootloader > Kernel phase 1 > Kernel phase 2

### OS Structures

- 과제 질문이 많이 들어옴. 윈도우즈 시스템에서 하지 마세용.
- 운영체제를 새로 하나 만들다고 생각해보죠:
  - 절대적인 답도 없고 최고의 방법도 없음. 대충 이렇게 했더니 성공적인 운영체제가 만들어지더라.
  - 그래서 우리는 운영체제가 일반적으로 어떻게 되어있고, 성공한 운영체제는 어떻더라 같은 얘기만 할거임.
  - 기본적으로 요구사항과 목적을 달성할 수 있어야. 스펙을 잘 정의해야 한다.
    - 어떤 하드웨어로, 어떤 종류의 시스템에서, 어떤 환경에서, ...
    - 사용자: 사용하기 편하고 배우기 쉬워야, 믿을 수 있어야, 안전해야, 빨라야.
    - 시스템: 설계하기 쉬워야, 구현하기 쉬워야, 유지보수가 쉬워야, 유연해야, 오류없어야, 효율적이어야.
  - 어떻게 구현할까?
    - 초기 운영체제는 어셈블리로 작성. 그 이후로는 Algol, PL/1 사용.
    - 오늘 날에는 굉장히 많은 시스템이 C/C++로 작성됨. 시스템을 하나의 언어만으로 구현하지 않음.
    - 리눅스는 대부분 C로 작성됨. 토발즈가 C++ 안 좋아함. 저도 C++ 안 좋아해요. 언어가 지저분해.
- 운영체제의 구조:
  - 리눅스 커널은 monolithic 구조: https://makelinux.github.io/kernel/map/
    - MS-DOS 방식은 심플하지만 유지보수가 어려움. 레이어드는 유지보수 쉽지만 성능 문제.
    - 리눅스 OS의 실체는 모듈끼리 강하게 커플링되어 있는 하나의 소프트웨어 커널(kernel).
    - 성능 이점이 있지만, 레이어드보다는 유지보수가 어렵고, 보안과 안정성 측면에서 문제가 있음.
  - 그 대안이 마이크로커널:
    - 커널에는 진짜 핵심적인 것만 남기고 유저 공간에 위임. 확장 쉽고, 포팅 쉽고, 보안도 향상.
    - 다만 유저 공간과 커널 공간 통신으로 성능 오버헤드가 발생함.
    - Tanenbaum-Tovalds debase: 토발즈가 리눅스 만들고 소개하는 글을 썼는데, 타넨바움이 "요즘 세상에 무슨 모놀리식이냐, 마이크로커널이 짱이다"라면서 까는 바람에 키배가 일어남. (https://www.oreilly.com/openbook/opensources/book/appa.html)
  - 요즘 시스템은 어떤 하나의 구조라고 말하기 어려움. 하이브리드.

## Processes

- 지금까지 오버뷰 얘기만 했음. 오늘부터는 실제 운영체제 얘기를 하겠습니다.
- 프로세스는 실행된 프로그램의 인스턴스:
  - 메모리에 로드되어 활성화되어있는 동적인 엔티티.
  - 프로그램은 디스크에 저장된 정적인 엔티티.
- 각 프로세스는 메모리에서 자기만의 주소 공간을 갖는다: code, data, heap, stack.
- 프로세스의 상태: new, ready, running, wait, terminated.
- `pid_t fork(void)`:
  - 루트에 init 프로세스가 있는데, 여기에 자식 프로세스를 만드는 것. 결국 하나의 트리를 이루게 됨.
  - 새 프로세스를 만드려면 당연히 커널 모드에서 해야. 따라서 시스템 콜(`fork`)을 사용해야 한다.
  - 어떤 프로세스에서 `fork()`를 하면 동일한 프로세스가 만들어짐.
  - 프로세스가 제대로 만들어지면 부모에게는 자식 프로세스의 PID를 반환, 자식에게는 0을 반환.
    - `pid_t getpid(void)`: 자신의 (진짜) PID.
    - `pid_t getppid(void)`: 부모의 PID.
  - 자식 프로세스는 `fork` 직후의 인스트럭션을 실행한다.
  - `fork`하는 시점의 메모리 섹션을 그대로 복제하므로, 변수도 `fork` 시점의 값을 갖는다.
  - 부모 프로세스와 자식 프로세스는 독립적임. 자식은 자식의 인생을 살아야 해요.
- `exec` family:
  - 현재 프로세스의 이미지를 새 프로세스 이미지로 교체.
  - 현재 주소 공간을 날리고 새로운 내용을 채운다. `exec("vi")`하면 vi를 실행하는 프로세스가 됨.
  - 여러분이 탐색기를 띄웠어요. 탐색기에서 파워포인트를 더블클릭하면 탐색기가 운영체제한테 `fork`를 날리죠. 그러면 탐색기 프로세스가 하나 더 만들어집니다. 근데 파워포인트를 실행해야하니 `exec`로 스스로를 교체.
- `void exit(int status)`:
  - 프로세스를 삭제한다. 프로세스의 반환 값이 부모 프로세스에게 전달됨.
  - `pid_t wait(int *wstatus)`: 부모 프로세스는 `wait` 시스템 콜을 통해 자식의 반환 값을 기다림.
  - `pid_t waitpid(pid_t pid, int* status, int options)`: 특정 자식을 기다림.
  - `void abort(void)`: 특정 프로세스와 그 부모까지 삭제.
  - 좀비 프로세스:
    - 자식이 삭제됐는데 부모 프로세스가 `wait`를 하지 않는다면?
    - 자식의 반환 값과 PID가 남음. 따라서 종료되었지만 삭제되지는 않은 좀비가 됨.
  - 고아 프로세스:
    - 부모가 삭제된 자식 프로세스.
    - 고아 프로세스를 방지하려면:
      - 부모가 삭제될 때 그 자식도 삭제해는 cascading termination.
      - 아니면 다른 프로세스의 자식으로 만드는 reparenting. 어떤 프로세스의 자식으로 만들 것인가?
        - 옛날 시스템 중에는 부모의 부모가 입양하는 경우도 있었음.
        - 리눅스는 `init` 프로세스의 자식으로 만든다. `init`은 주기적으로 `wait`을 호출해 자식을 정리.
- 프로세스의 구현:
  - 각 프로세스는 Process Control Blcok(PCB)로 표현된다.
  - 프로세스에 대한 모든 정보가 PCB에 담겨있음.
  - 상태, PC(Program Counter), PID, PPID, 레지스터, 메모리 제한, CPU 스케줄링 정보 등.
- IPC(Inter-Process Communication):
  - 하나의 프로그램을 여러 프로세스로 만드는게 굉장히 흔한 모델.
  - 프로세스끼리 통신을 해야 하는데...
  - 공유 메모리(shared memory):
    - 프로세스가 운영체제에게 명시적으로 공유 메모리를 요청할 수 있음: `shm_open`
    - 운영체제가 공유 메모리를 제공한 뒤에는 신경쓰지 않아도 됨.
    - 하지만 관리가 안 된다. 각종 동시성 문제가 일어남.
  - 메시지 패싱(message passing):
    - 택배. `send`, `receive`를 이용해서 프로세스간 메시지 교환을 할 수 있음.
    - 운영체제가 다 알아서 해준다. 마이크로커널이 메시지 패싱을 적극 활용. 분산환경에 좋음.
  - 시그널:
    - 강아지가 시그널을 날려요(?)
    - 프로세스에게 이벤트를 알리는 IPC 매커니즘. 동기적일수도 있고, 비동기적일수도 있음.
    - 소프트웨어 인터럽트라고 생각할수도. 시그널 핸들러가 시그널을 처리한다.
    - `sigaction`으로 어떤 시그널을 받았을 때 어떤 행동을 하라고 정의할 수 있음.
    - 시그널 핸들러도 PCB에 있음. `fork` 어떤 시그널은 복사가 되지만, 어떤 시그널은 안 됨.
  - 로컬 기기에서만 IPC를 할 수 있을까?
    - Remote Procedure Call(RPC)로 원격 프로시저를 호출할 수도 있음.
    - 실제로는 stub을 사용하고, 운영체제의 RPC 레이어에서 통신을 처리해준다.
    - XDR: 범용적인 데이터 표현 형식. 시스템마다 엔디언이 다르기 때문에 RPC 데이터를 XDR로 표현.


