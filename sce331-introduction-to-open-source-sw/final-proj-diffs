diff --git a/book.toml b/book.toml
index c7b4b3e..029409c 100644
--- a/book.toml
+++ b/book.toml
@@ -4,13 +4,13 @@ title = "Command Line Applications in Rust"
 # ...but friends call it "Clair"
 authors = ["The Rust CLI Working Group"]
 multilingual = false
-language = "en"
+language = "ko"
 src = "src"

 [output.html]
 curly-quotes = true
 additional-css = ["src/special-content.css"]
-git-repository-url = "https://github.com/rust-cli/book"
+git-repository-url = "https://github.com/parksb/rust-cli-book-ko-kr"
 site-url = "/book/"

 # Linkcheck doesn't find images/SVG so it's not enabled for now
diff --git a/src/README.md b/src/README.md
index 9a3b5b2..40e01f2 100644
--- a/src/README.md
+++ b/src/README.md
@@ -1,30 +1,24 @@
-# Command line apps in Rust
+# 러스트 커맨드라인 애플리케이션

-Rust is a statically compiled, fast language with great tooling and a rapidly growing ecosystem.
-That makes it a great fit for writing command line applications:
-They should be small, portable, and quick to run.
-Command line applications are also a great way to get started with learning Rust;
-or to introduce Rust to your team!
+러스트는 뛰어난 도구와 급격히 성장하는 생태계, 높은 성능을 갖춘 정적 컴파일 언어입니다.
+러스트는 작고, 휴대성이 높으며, 빠르게 실행해야 하는 커맨드라인 애플리케이션을 작성할 때 매우 적합합니다.
+또한 커맨드라인 애플리케이션은 러스트 학습을 시작하는 데 훌륭한 교재이기도 하며,
+여러분의 팀에 러스트를 소개하는 일종의 매개체가 될 수도 있습니다!

-Writing a program with a simple command line interface (CLI)
-is a great exercise for a beginner
-who is new to the language and wants to get a feel for it.
-There are many aspects to this topic, though,
-that often only reveal themselves later on.
+간단한 커맨드라인 인터페이스(command line interface, CLI) 프로그램을 작성하는 것은
+러스트를 이제 막 접하고 감을 잡고자 하는 초심자에게 좋은 연습이 됩니다.
+이 주제에는 종종 나중에야 깨닫게 되는 다양한 측면이 있습니다.

-This book is structured like this:
-We start with a quick tutorial,
-after which you'll end up with a working CLI tool.
-You'll be exposed to a few of the core concepts of Rust
-as well as the main aspects of CLI applications.
-What follows are chapters that go into more detail
-on some of these aspects.
+이 책은 다음과 같이 구성되어 있습니다:
+우선 빠르게 튜토리얼을 시작하고 CLI 툴을 완성하게 됩니다.
+여러분은 러스트의 몇몇 핵심적인 개념과 CLI 애플리케이션의 주요 특성을 접하게 될 것입니다.
+이러한 측면 중 일부에 대해서는 두 번째 챕터에서 더욱 자세히 설명합니다.

-One last thing before we dive right into CLI applications:
-If you find an error in this book
-or want to help us write more content for it,
-you can find its source [in the CLI book repository][book-src].
-We'd love to hear your feedback!
-Thank you!
+CLI 애플리케이션에 바로 뛰어들기 전에 마지막으로 짚고 넘어갈 것이 있습니다.
+만약 이 책에서 오류를 찾거나, 더 많은 내용을 담을 수 있도록 돕고 싶다면,
+[CLI 책 저장소][book-src-ko-kr] ([원본 저장소][book-src])에서 소스를 확인하실 수 있습니다.
+여러분의 피드백을 환영합니다.
+감사합니다!

+[book-src-ko-kr]: https://github.com/parksb/rust-cli-book-ko-kr
 [book-src]: https://github.com/rust-cli/book
diff --git a/src/SUMMARY.md b/src/SUMMARY.md
index f861e6c..e516b18 100644
--- a/src/SUMMARY.md
+++ b/src/SUMMARY.md
@@ -1,20 +1,20 @@
 # Summary

-[Getting started](./README.md)
+[시작하기](./README.md)

-- [A command line app in 15 minutes](./tutorial/README.md)
-  - [Project setup](./tutorial/setup.md)
-  - [Parsing command line arguments](./tutorial/cli-args.md)
-  - [First implementation](./tutorial/impl-draft.md)
-  - [Nicer error reporting](./tutorial/errors.md)
-  - [Output for humans and machines](./tutorial/output.md)
-  - [Testing](./tutorial/testing.md)
-  - [Packaging and distributing a Rust tool](./tutorial/packaging.md)
-- [In-depth topics](./in-depth/README.md)
-  - [Signal handling](./in-depth/signals.md)
-  - [Using config files](./in-depth/config-files.md)
-  - [Exit codes](./in-depth/exit-code.md)
-  - [Communicating with humans](./in-depth/human-communication.md)
-  - [Communicating with machines](./in-depth/machine-communication.md)
-  - [Rendering documentation for your CLI apps](./in-depth/docs.md)
-- [Resources](./resources/README.md)
+- [15분 안에 커맨드라인 앱 작성하기](./tutorial/README.md)
+  - [프로젝트 준비](./tutorial/setup.md)
+  - [커맨드라인 인자 파싱하기](./tutorial/cli-args.md)
+  - [첫 구현](./tutorial/impl-draft.md)
+  - [더 나은 에러 보고](./tutorial/errors.md)
+  - [사람과 기계를 위한 출력](./tutorial/output.md)
+  - [테스트](./tutorial/testing.md)
+  - [러스트 도구 패키징, 배포하기](./tutorial/packaging.md)
+- [더 깊은 주제](./in-depth/README.md)
+  - [시그널 다루기](./in-depth/signals.md)
+  - [설정 파일 사용하기](./in-depth/config-files.md)
+  - [종료 코드](./in-depth/exit-code.md)
+  - [사람과 소통하기](./in-depth/human-communication.md)
+  - [기계와 소통하기](./in-depth/machine-communication.md)
+  - [CLI 앱을 위한 문서 렌더링하기](./in-depth/docs.md)
+- [자료](./resources/README.md)
diff --git a/src/in-depth/README.md b/src/in-depth/README.md
index 13b6edd..4b504c3 100644
--- a/src/in-depth/README.md
+++ b/src/in-depth/README.md
@@ -1,4 +1,4 @@
-# In-depth topics
+# 더 깊은 주제

-A small collection of chapters covering some more details
-that you might care about when writing your command line application.
+커맨드라인 애플리케이션을 작성할 때 여러분이 신경 써야 하는 부분에 대해
+더욱 자세한 내용을 다루는 챕터입니다.
diff --git a/src/in-depth/config-files.md b/src/in-depth/config-files.md
index 4588b11..2026518 100644
--- a/src/in-depth/config-files.md
+++ b/src/in-depth/config-files.md
@@ -1,18 +1,18 @@
-# Using config files
+# 설정 파일 사용하기

-Dealing with configurations can be annoying
-especially if you support multiple operating systems
-which all have their own places
-for short- and long-term files.
+설정을 다루는 것은 짜증 날 수도 있습니다.
+특히 다양한 운영체제를 지원해야 하는 경우
+각자의 단기, 장기 보관 파일 저장 위치를
+고려해야 하므로 더욱 그렇습니다.

-There are multiple solutions to this,
-some being more low-level than others.
+여기엔 여러 해결 방안이 있는데,
+일부는 다른 것들보다 더욱 로우 레벨의 해결책이기도 합니다.

-The easiest crate to use for this is [`confy`].
-It asks you for the name of your application
-and requires you to specify the config layout
-via a `struct` (that is `Serialize`, `Deserialize`)
-and it will figure out the rest!
+이때 사용하기 가장 쉬운 크레이트는 [`confy`]입니다.
+[`confy`]는 여러분의 애플리케이션 이름을 묻고
+`struct`(`Serialize`, `Deserialize`를 derive)를 통해
+설정 레이아웃을 명시하도록 합니다.
+이렇게만 하면 나머지는 [`confy`]가 찾아냅니다!

 ```rust,ignore
 #[derive(Debug, Serialize, Deserialize)]
@@ -29,22 +29,22 @@ fn main() -> Result<(), io::Error> {
 }
 ```

-This is incredibly easy to use
-for which you of course surrender configurability.
-But if a simple config is all you want,
-this crate might be for you!
+물론 설정 가능성(configurability)을 포기해야 하지만,
+[`confy`]는 정말 사용하기 쉽습니다.
+여러분이 간단한 설정만을 원한다면
+[`confy`] 크레이트가 바로 여러분을 위한 것일 수 있습니다.

 [`confy`]: https://docs.rs/confy/0.3.1/confy/

-## Configuration environments
+## 설정 환경

 <aside class="todo">

 **TODO**

-1. Evaluate crates that exist
-2. Cli-args + multiple configs + env variables
-3. Can [`configure`] do all this? Is there a nice wrapper around it?
+1. 기존 크레이트를 평가한다.
+2. Cli-args + 다양한 설정 + 환경 변수
+3. 모든 경우에 [`configure`]를 쓸 수 있는가? 더 나은 래퍼가 있는가?

 </aside>

diff --git a/src/in-depth/docs.md b/src/in-depth/docs.md
index c077514..2e3227a 100644
--- a/src/in-depth/docs.md
+++ b/src/in-depth/docs.md
@@ -1,34 +1,30 @@
-# Rendering documentation for your CLI apps
+# CLI 앱을 위한 문서 렌더링하기

-Documentation for CLIs usually consists of
-a `--help` section in the command
-and a manual (`man`) page.
+CLI를 위한 문서는 보통
+명령의 `--help` 섹션이나
+매뉴얼(`man`) 페이지로 구성됩니다.

-Both can be automatically generated
-when using [`clap`](https://crates.io/crates/clap), via
-[`clap_mangen`](https://crates.io/crates/clap_mangen) crate.
+[`clap`](https://crates.io/crates/clap)을 사용하면
+[`clap_mangen`](https://crates.io/crates/clap_mangen) 크레이트를 통해
+둘 다 자동으로 생성할 수 있습니다.

 ```rust,ignore
 #[derive(Parser)]
 pub struct Head {
-    /// file to load
+    /// 로드할 파일
     pub file: PathBuf,
-    /// how many lines to print
+    /// 출력할 라인 개수
     #[arg(short = "n", default_value = "5")]
     pub count: usize,
 }
 ```

-Secondly, you need to use a `build.rs`
-to generate the manual file at compile time
-from the definition of your app
-in code.
+두 번째로, 컴파일 타임에 코드에 있는
+앱의 정의로부터 매뉴얼 파일을 생성하려면 `
+`build.rs`를 사용해야 합니다.

-There are a few things to keep in mind
-(such as how you want to package your binary)
-but for now
-we simply put the `man` file
-next to our `src` folder.
+바이너리 패키징 방식 등 고려해야 할 사항이 있지만,
+지금은 `src` 폴더 옆에 `man` 을 두도록 하겠습니다.

 ```rust,ignore
 use clap::CommandFactory;
@@ -50,9 +46,7 @@ fn main() -> std::io::Result<()> {
 }
 ```

-When you now compile your application
-there will be a `head.1` file
-in your project directory.
+이제 애플리케이션을 컴파일하면 프로젝트 디렉토리에
+`head.1` 파일이 만들어집니다.

-If you open that in `man`
-you'll be able to admire your free documentation.
+`man`에서 해당 파일을 열면 공짜 문서에 감탄할 것입니다.
diff --git a/src/in-depth/exit-code.md b/src/in-depth/exit-code.md
index ce7ed76..7e8b4f0 100644
--- a/src/in-depth/exit-code.md
+++ b/src/in-depth/exit-code.md
@@ -1,39 +1,35 @@
-# Exit codes
+# 종료 코드

-A program doesn't always succeed.
-And when an error occurs,
-you should make sure to emit the necessary information correctly.
-In addition to
-[telling the user about errors](human-communication.html),
-on most systems,
-when a process exits,
-it also emits an exit code
-(an integer between 0 and 255 is compatible with most platforms).
-You should try to emit the correct code
-for your program's state.
-For example,
-in the ideal case when your program succeeds,
-it should exit with `0`.
+프로그램이 항상 성공적으로 동작하지는 않습니다.
+에러가 발생했을 때 여러분은 필수적인 정보를 올바르게 내보내야 합니다.
+[사용자에게 에러에 대해 말해주기](human-communication.html)에 더해서,
+대부분의 시스템에서 프로세스가 종료될 때
+종료 코드를 내보냅니다.
+(0에서 255까지의 정수가 대부분의 플랫폼에서 호환됩니다.)
+여러분은 프로그램의 상태에 알맞은 코드를 내보내야 합니다.
+예를 들어서, 프로그램이 성공적으로 동작하는
+이상적인 상황에서 종료 코드는 `0`이 되어야 합니다.

-When an error occurs, it gets a bit more complicated, though.
-In the wild,
-many tools exit with `1` when a common failure occurs.
-Currently, Rust sets an exit code of `101` when the process panicked.
-Beyond that, people have done many things in their programs.
+에러가 발생하면 조금 더 복잡해집니다.
+현실에서는 프로그램에 일반적인 문제가 생겼을 때
+많은 경우 종료 코드로 `1`을 내보냅니다.
+러스트는 프로세스에 패닉이 일어났을 때
+`101`을 종료 코드로 사용합니다.
+이를 넘어서, 사람들은 자신의 프로그램에서 많은 것을 해왔습니다.

-So, what to do?
-The BSD ecosystem has collected a common definition for their exit codes
-(you can find them [here][`sysexits.h`]).
-The Rust library [`exitcode`] provides these same codes,
-ready to be used in your application.
-Please see its API documentation for the possible values to use.
+뭘 할 수 있을까요?
+BSD 생태계는 종료 코드에 대한 공통의 정의를 모아뒀습니다.
+([여기][`sysexits.h`]에서 찾아볼 수 있습니다.)
+러스트 라이브러리 [`exitcode`]는 이와 같은 코드를 제공하며,
+여러분의 애플리케이션에서 바로 사용할 수 있습니다.
+사용 가능한 값을 보려면 API 문서를 참고하세요.

-After you add the `exitcode` dependency to your `Cargo.toml`,
-you can use it like this:
+`Cargo.toml`에 `exitcode` 디펜던시를 추가한 뒤에
+아래와 같이 사용할 수 있습니다:

 ```rust,ignore
 fn main() {
-    // ...actual work...
+    // ...실제 작업...
     match result {
         Ok(_) => {
             println!("Done!");
diff --git a/src/in-depth/human-communication.md b/src/in-depth/human-communication.md
index 51e7d9e..7432640 100644
--- a/src/in-depth/human-communication.md
+++ b/src/in-depth/human-communication.md
@@ -1,54 +1,47 @@
-# Communicating with humans
+# 사람과 소통하기

-Make sure to read [the chapter on CLI output][output]
-in the tutorial first.
-It covers how to write output to the terminal,
-while this chapter will talk about _what_ to output.
+먼저 [CLI 출력 챕터][output]를 읽을 것을 권장합니다.
+[CLI 출력 챕터][output]에서는 터미널에 출력을 어떻게 내는지 설명했다면,
+이 챕터에서는 무엇을 출력할지 설명합니다.

 [output]: ../tutorial/output.html

-## When everything is fine
-
-It is useful to report on the application's progress
-even when everything is fine.
-Try to be informative and concise in these messages.
-Don't use overly technical terms in the logs.
-Remember:
-the application is not crashing
-so there's no reason for users to look up errors.
-
-Most importantly,
-be consistent in the style of communication.
-Use the same prefixes and sentence structure
-to make the logs easily skimmable.
-
-Try to let your application output tell a story
-about what it's doing
-and how it impacts the user.
-This can involve showing a timeline of steps involved
-or even a progress bar and indicator for long-running actions.
-The user should at no point
-get the feeling that the application is doing something mysterious
-that they cannot follow.
-
-## When it's hard to tell what's going on
-
-When communicating non-nominal state it's important to be consistent.
-A heavily logging application that doesn't follow strict logging levels
-provides the same amount, or even less information
-than a non-logging application.
-
-Because of this,
-it's important to define the severity of events
-and messages that are related to it;
-then use consistent log levels for them.
-This way users can select the amount of logging themselves
-via `--verbose` flags
-or environment variables (like `RUST_LOG`).
-
-The commonly used `log` crate
-[defines][log-levels] the following levels
-(ordered by increasing severity):
+## 모든 것이 순조로울 때
+
+모든 것이 순조로울 때도 사용자에게
+애플리케이션의 진행 상황을 보여주는 것이 좋습니다.
+이때 메시지는 간결하고 유익해야 합니다.
+로그에 지나치게 기술적인 용어를 사용하지 마세요.
+그리고, 애플리케이션이 충돌(crash)한 것이 아니므로
+사용자가 에러를 찾아볼 필요는 없다는 사실을 기억하세요.
+
+커뮤니케이션 스타일이 일관되어야 한다는 점이
+가장 중요합니다.
+로그를 쉽게 파악할 수 있도록
+항상 같은 접두어와 문장 구조를 사용하세요.
+
+애플리케이션의 출력이 지금 프로그램에 무슨 일이 일어나고 있는지,
+이 일이 사용자에게 어떤 영향을 미치는지 이야기하도록 하세요.
+이를 위해 단계별 타임라인을 보여줄 수도 있고,
+오래 걸리는 작업에서는 프로그래스 바와 인디케이터를 보여줄 수도 있습니다.
+사용자로 하여금 애플리케이션이 하는 일을 따라갈 수 있게 만들고,
+프로그램이 하는 일이 비밀스럽게 느껴지지 않도록 해야 합니다.
+
+## 무슨 일이 일어나는지 말하기 어려울 때
+
+사소한 상태를 알릴 때는 일관성을 유지하는 것이 중요합니다.
+많은 로그를 남기면서도 로그 레벨을 엄격히 따르지 않는
+애플리케이션은 로그를 남기지 않는 애플리케이션보다
+적은 정보를 제공합니다.
+
+따라서 이벤트와 메시지의 중요도를
+정의하여 일관된 로그 레벨을 사용하는 것이 중요합니다.
+이러한 방식으로 사용자는 `--verbose` 플래그 또는
+환경 변수(`RUST_LOG` 등)를 통해 직접 로그 양을 조절할 수 있습니다.
+
+일반적으로 사용하는 `log` 크레이트는
+아래와 같은 로그 레벨을 [정의][log-levels]합니다.
+(중요도 오름차순)

 - trace
 - debug
@@ -56,22 +49,19 @@ The commonly used `log` crate
 - warning
 - error

-It's a good idea to think of _info_ as the default log level.
-Use it for, well, informative output.
-(Some applications that lean towards a more quiet output style
-might only show warnings and errors by default.)
+_info_ 를 기본 로그 레벨로 설정하여 유용한 출력을
+제공하는 것이 좋습니다. (더 조용한 출력 스타일을 지향하는
+일부 애플리케이션은 기본적으로 경고와 에러만 보여주기도 합니다.)

-Additionally,
-it's always a good idea to use similar prefixes
-and sentence structure across log messages,
-making it easy to use a tool like `grep` to filter for them.
-A message should provide enough context by itself
-to be useful in a filtered log
-while not being *too* verbose at the same time.
+추가로, 모든 로그 메시지에서 비슷한 접두어와
+문장 구조를 사용하는 것은 좋은 생각입니다.
+이렇게 하면 `grep`과 같은 도구를 사용해 로그를 쉽게 필터링할 수 있습니다.
+메시지에는 필터링된 로그에서 유용한 정보를 얻을 수 있을 정도로
+충분한 맥락을 제공하되, *너무* 상세한 정보를 담지는 않아야 합니다.

 [log-levels]: https://docs.rs/log/0.4.4/log/enum.Level.html

-### Example log statements
+### 로그 예시

 ```console
 error: could not find `Cargo.toml` in `/home/you/project/`
@@ -82,7 +72,7 @@ error: could not find `Cargo.toml` in `/home/you/project/`
 => Downloading packages...
 ```

-The following log output is taken from [wasm-pack]:
+아래는 [wasm-pack]의 로그 출력입니다:

 ```console
  [1/7] Adding WASM target...
@@ -100,41 +90,38 @@ The following log output is taken from [wasm-pack]:
  Done in 1 second
 ```

-## When panicking
+## 패닉이 일어났을 때

-One aspect often forgotten is that
-your program also outputs something when it crashes.
-In Rust, "crashes" are most often "panics"
-(i.e., "controlled crashing"
-in contrast to "the operating system killed the process").
-By default,
-when a panic occurs,
-a "panic handler" will print some information to the console.
+자주 잊히는 측면 중 하나는
+프로그램이 충돌할 때도 뭔가가 출력된다는 점입니다.
+러스트에서 "충돌"은 대개 "패닉"을 의미합니다.
+(즉, "운영체제가 프로세스를 강제로 종료시킨 것"과 다르게
+"통제된 충돌"입니다.)
+패닉이 발생하면 기본적으로 "패닉 핸들러"가
+몇 가지 정보를 콘솔에 출력합니다.

-For example,
-if you create a new binary project
-with `cargo new --bin foo`
-and replace the content of `fn main` with `panic!("Hello World")`,
-you get this when you run your program:
+예를 들어,
+`cargo new --bin foo`로 새로운 바이너리 프로젝트를
+생성하고 `fn main`의 내용을 `panic!("Hello World")`로 고치면
+프로그램을 실행했을 때 아래와 같은 결과가 나오게 됩니다:

 ```console
 thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
 note: Run with `RUST_BACKTRACE=1` for a backtrace.
 ```

-This is useful information to you, the developer.
-(Surprise: the program crashed because of line 2 in your `main.rs` file).
-But for a user who doesn't even have access to the source code,
-this is not very valuable.
-In fact, it most likely is just confusing.
-That's why it's a good idea to add a custom panic handler,
-that provides a bit more end-user focused output.
+이 정보는 개발자에게 유용합니다.
+(놀랍게도 `main.rs` 파일의 두 번째 줄에서 충돌이 발생했습니다.)
+하지만 소스 코드를 볼 수 없는 사용자에게는 그다지
+가치 있는 정보가 아닙니다.
+사실 사용자 입장에서는 혼란에 더 가깝습니다.
+따라서 커스텀 패닉 핸들러를 추가하여
+더욱 사용자 친화적인 정보를 제공해야 합니다.

-One library that does just that is called [human-panic].
-To add it to your CLI project,
-you import it
-and call the `setup_panic!()` macro
-at the beginning of your `main` function:
+이를 위해 사용할 수 있는 라이브러리 중 하나는 [human-panic]입니다.
+[human-panic]을 CLI 프로젝트에 추가하려면
+`main` 함수의 시작 부분에서 `setup_panic!()` 매크로를
+호출하면 됩니다:

 ```rust,ignore
 use human_panic::setup_panic;
@@ -146,8 +133,8 @@ fn main() {
 }
 ```

-This will now show a very friendly message,
-and tells the user what they can do:
+이제 사용자 친화적인 메시지가 출력됩니다.
+사용자는 메시지를 읽고 어떻게 해야 하는지 알 수 있습니다:

 ```console
 Well, this is embarrassing.
diff --git a/src/in-depth/machine-communication-stdin.rs b/src/in-depth/machine-communication-stdin.rs
index c70301f..44b0a6e 100644
--- a/src/in-depth/machine-communication-stdin.rs
+++ b/src/in-depth/machine-communication-stdin.rs
@@ -6,11 +6,11 @@ use std::{
     path::PathBuf,
 };

-/// Count the number of lines in a file or stdin
+/// 파일 또는 stdin의 라인 수를 센다
 #[derive(Parser)]
 #[command(arg_required_else_help = true)]
 struct Cli {
-    /// The path to the file to read, use - to read from stdin (must not be a tty)
+    /// 읽을 파일의 경로, - 를 사용하면 stdin에서 읽음 (tty는 안 됨)
     file: PathBuf,
 }

diff --git a/src/in-depth/machine-communication-wc.rs b/src/in-depth/machine-communication-wc.rs
index 05a314b..4b825fb 100644
--- a/src/in-depth/machine-communication-wc.rs
+++ b/src/in-depth/machine-communication-wc.rs
@@ -1,11 +1,11 @@
 use clap::Parser;
 use std::path::PathBuf;

-/// Count the number of lines in a file
+/// 파일의 라인수를 센다
 #[derive(Parser)]
 #[command(arg_required_else_help = true)]
 struct Cli {
-    /// The path to the file to read
+    /// 읽을 파일의 경로
     file: PathBuf,
 }

diff --git a/src/in-depth/machine-communication.md b/src/in-depth/machine-communication.md
index aa72b74..b8d5e3a 100644
--- a/src/in-depth/machine-communication.md
+++ b/src/in-depth/machine-communication.md
@@ -1,39 +1,37 @@
-# Communicating with machines
+# 기계와 소통하기

-The power of command-line tools really comes to shine
-when you are able to combine them.
-This is not a new idea:
-In fact, this is a sentence from the [Unix philosophy]:
+커맨드라인 도구의 진정한 힘은 여러 도구를
+결합할 때 드러납니다.
+이는 새로운 사실이 아닙니다.
+아래는 [유닉스 철학]에 나오는 문장입니다:

-> Expect the output of every program to become the input to another, as yet unknown, program.
+> "모든 프로그램 출력이 아직 잘 알려지지 않은 프로그램이라고 할지라도 다른 프로그램에 대한 입력이 될 수 있게 할 것."

-[Unix philosophy]: https://en.wikipedia.org/wiki/Unix_philosophy
+[유닉스 철학]: https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%89%EC%8A%A4_%EC%B2%A0%ED%95%99

-If our programs fulfill this expectation,
-our users will be happy.
-To make sure this works well,
-we should provide not just pretty output for humans,
-but also a version tailored to what other programs need.
-Let's see how we can do this.
+프로그램이 이 기대를 충족하면
+사용자가 행복해집니다.
+이러한 철학을 따르기 위해
+우리는 사람들을 위한 보기 좋은 출력뿐만 아니라
+다른 프로그램이 필요로 하는 것을 제공해야 합니다.
+어떻게 하는지 살펴봅시다.

 <aside>

-**Note:**
-Make sure to read [the chapter on CLI output][output]
-in the tutorial first.
-It covers how to write output to the terminal.
+**참고:**
+먼저 [CLI 출력 챕터][output]을 읽어보세요.
+[CLI 출력 챕터][output]에서는 터미널에 출력을 내는 방법에 대해 설명합니다.

 [output]: ../tutorial/output.html

 </aside>

-## Who's reading this?
+## 누가 출력을 읽나요?

-The first question to ask is:
-Is our output for a human in front of a colorful terminal,
-or for another program?
-To answer this,
-we can use a crate like [is-terminal]:
+첫 번째 질문은: 출력이 컬러풀한 터미널 앞에 있는 사람을 위한 것인지,
+또 다른 프로그램을 위한 것인지 묻는 것입니다.
+이 질문에 대답하기 위해
+[is-terminal]과 같은 크레이트를 사용할 수 있습니다:

 [is-terminal]: https://crates.io/crates/is-terminal

@@ -47,12 +45,11 @@ if std::io::stdout().is_terminal() {
 }
 ```

-Depending on who will read our output,
-we can then add extra information.
-Humans tend to like colors,
-for example,
-if you run `ls` in a random Rust project,
-you might see something like this:
+출력을 읽을 대상에 따라 추가적인 정보를
+제공할 수 있습니다.
+사람들은 보통 색깔이 있는 출력을 좋아합니다.
+예를 들어 임의의 러스트 프로젝트에서
+`ls`를 실행하면 아래와 같은 결과를 볼 수 있을 것입니다:

 ```console
 $ ls
@@ -62,16 +59,14 @@ Cargo.lock           README.md            src
 Cargo.toml           convey_derive        target
 ```

-Because this style is made for humans,
-in most configurations
-it'll even print some of the names (like `src`) in color
-to show that they are directories.
-If you instead pipe this to a file,
-or a program like `cat`,
-`ls` will adapt its output.
-Instead of using columns that fit my terminal window
-it will print every entry on its own line.
-It will also not emit any colors.
+이 스타일은 사람을 위해 만들어졌기 때문에, 대부분의 설정에서
+`src`와 같은 일부 이름을 다른 색상으로 보여줌으로써
+`src`가 디렉토리임을 표시합니다.
+그러나 이를 파일이나 `cat` 같은 프로그램에 파이프하면
+`ls`는 그에 맞는 출력을 내보냅니다.
+터미널 윈도우에 알맞은 컬럼 레이아웃을 출력하는 대신
+개별 행에 파일 이름을 출력합니다.
+또한 여기에는 아무런 색깔도 적용되어 있지 않습니다.

 ```console
 $ ls | cat
@@ -89,83 +84,75 @@ src
 target
 ```

-## Easy output formats for machines
-
-Historically,
-the only type of output command-line tools produced were strings.
-This is usually fine for people in front of terminals,
-who are able to read text
-and reason about its meaning.
-Other programs usually don't have that ability, though:
-The only way for them to understand the output of a tool
-like `ls`
-is if the author of the program included a parser
-that happens to work for whatever `ls` outputs.
-
-This often means
-that output was limited to what is easy to parse.
-Formats like TSV (tab-separated values),
-where each record is on its own line,
-and each line contains tab-separated content,
-are very popular.
-These simple formats based on lines of text
-allow tools like `grep`
-to be used on the output of tools like `ls`.
-`| grep Cargo` doesn't care if your lines are from `ls` or file,
-it will just filter line by line.
-
-The downside of this is that you can't use
-an easy `grep` invocation to filter all the directories that `ls` gave you.
-For that, each directory item would need to carry additional data.
-
-## JSON output for machines
-
-Tab-separated values is a simple way
-to output structured data
-but it requires the other program to know which fields to expect
-(and in which order)
-and it's difficult to output messages of different types.
-For example,
-let's say our program wanted to message the consumer
-that it is currently waiting for a download,
-and afterwards output a message describing the data it got.
-Those are very different kinds of messages
-and trying to unify them in a TSV output
-would require us to invent a way to differentiate them.
-Same when we wanted to print a message that contains two lists
-of items of varying lengths.
-
-Still,
-it's a good idea to choose a format that is easily parsable
-in most programming languages/environments.
-Thus,
-over the last years a lot of applications gained the ability
-to output their data in [JSON].
-It's simple enough that parsers exist in practically every language
-yet powerful enough to be useful in a lot of cases.
-While its a text format that can be read by humans,
-a lot of people have also worked on implementations that are very fast at
-parsing JSON data and serializing data to JSON.
+## 기계를 위한 쉬운 출력 형식
+
+역사적으로,
+커맨드라인 도구가 생성하는 출력은 대부분 문자열입니다.
+터미널 앞에 앉아 있는 사람이 보통 텍스트를 읽고
+의미를 추론할 수 있기 때문에 문자열을 출력해도 문제가 없습니다.
+하지만 프로그램에게는 그런 능력이 없습니다.
+즉, 어떤 프로그램이 `ls`와 같은 도구의 출력을 이해하려면
+프로그래머가 `ls`의 출력을 읽는 파서를 작성해야 합니다.
+
+이는 보통 출력이 파싱하기 쉬운 형식으로
+제한되어 있음을 의미합니다.
+각 레코드가 개별 라인에 들어가고,
+개별 라인에는 탭으로 구분된 내용이 들어가는
+TSV(tab-separated values, 탭으로 구분된 값)와 같은 형식은
+매우 인기있습니다.
+이처럼 텍스트 라인을 기반으로 하는 단순한 형식은
+`grep`과 같은 도구가 `ls`와 같은 다른 도구의
+출력을 사용할 수 있도록 해줍니다.
+`| grep Cargo`는 개별 라인이 `ls`에서 왔는지,
+파일에서 왔는지 신경쓰지 않으며, 라인별로
+필터링을 수행할 것입니다.
+
+단점은 `ls`가 제공한 모든 디렉토리를 필터링하는
+간단한 `grep` 호출을 사용할 수 없다는 점입니다.
+이를 위해서는 각 디렉토리 요소에 추가적인 데이터를 더해야 합니다.
+
+## 기계를 위한 JSON 출력
+
+TSV는 정형화된 데이터를 출력하는
+간단한 방법입니다. 그러나 출력에 TSV를 사용하려면
+다른 프로그램이 해당 출력에 어떤 필드가 있는지(그리고 어떤 순서인지)
+미리 알고 있어야 하며, 다른 타입의 메시지를 출력하기도 어렵습니다.
+예를 들어, 우리의 프로그램이 메시지를 출력해 다운로드를 기다리고 있음을
+다른 프로그램에게 알리고, 이후 다운로드한 데이터에 대해 설명하는
+메시지를 출력하고자 하는 경우를 생각해 볼 수 있습니다.
+이 경우 두 메시지의 성격은 매우 다르며,
+TSV 출력으로 이를 통합해 표현하려면
+둘을 구분할 방법을 고안해야 합니다.
+마찬가지로 길이가 다른 두 리스트를 출력하고자 할 때도
+같은 문제가 발생합니다.
+
+그러나 대부분의 프로그래밍 언어/환경에서
+쉽게 파싱 가능한 형식을 선택하는 것은 좋은 생각입니다.
+그래서 지난 몇 년 동안 많은 애플리케이션이 데이터를
+[JSON] 형식으로 출력하는 기능을 갖췄습니다.
+JSON은 거의 모든 언어가 파싱할 수 있는 충분히 간단한
+형식이면서도 다양한 상황에 유용하게 사용할 수 있습니다.
+JSON은 사람이 읽을 수 있는 텍스트 형식이며,
+많은 사람들이 JSON 데이터를 빠르게 파싱하고 직렬화하는
+구현체를 개발했습니다.

 [JSON]: https://www.json.org/

-In the description above,
-we've talked about "messages" being written by our program.
-This is a good way of thinking about the output:
-Your program doesn't necessarily only output one blob of data
-but may in fact emit a lot of different information
-while it is running.
-One easy way to support this approach when outputting JSON
-is to write one JSON document per message
-and to put each JSON document on new line
-(sometimes called [Line-delimited JSON][jsonlines]).
-This can make implementations as simple as using a regular `println!`.
+앞서 우리는 프로그램이 출력하는 "메시지"에 대해
+이야기했습니다.
+이는 프로그램의 출력에 대해 생각해 보는 좋은 방법입니다.
+프로그램은 단지 하나의 데이터 덩어리만 출력하지 않고
+실행 중에 다양한 종류의 정보를 출력할 수 있습니다.
+JSON을 출력할 때 이러한 접근법을 지원할 수 있는
+쉬운 방법 중 하나는 메시지 당 하나의 JSON 문서를 작성하고
+새로운 라인에 각 JSON 문서를 넣는 것입니다.
+(이 방법을 때로 [Line-delimited JSON][jsonlines]라고 부릅니다.)
+이를 통해 일반적인 `println!`을 사용하는 것만큼 간단한 구현이 가능합니다.

 [jsonlines]: https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON

-Here's a simple example,
-using the `json!` macro from [serde_json]
-to quickly write valid JSON in your Rust source code:
+아래는 [serde_json]의 `json!` 매크로를 이용해
+러스트 소스코드에서 빠르게 JSON을 작성하는 간단한 예시입니다:

 [serde_json]: https://crates.io/crates/serde_json

@@ -173,7 +160,7 @@ to quickly write valid JSON in your Rust source code:
 {{#include machine-communication.rs}}
 ```

-And here is the output:
+출력은 아래와 같습니다:

 ```console
 $ cargo run -q
@@ -182,13 +169,13 @@ $ cargo run -q -- --json
 {"content":"Hello world","type":"message"}
 ```

-(Running `cargo` with `-q` suppresses its usual output.
-The arguments after `--` are passed to our program.)
+(`cargo`를 `-q`와 함께 실행하면 출력을 생략할 수 있습니다.
+`--` 뒤의 인수는 프로그램으로 전달됩니다.)

-### Practical example: ripgrep
+### 실습 예시: ripgrep

-_[ripgrep]_ is a replacement for _grep_ or _ag_, written in Rust.
-By default it will produce output like this:
+[ripgrep]은 grep이나 ag를 대체하는 러스트 프로그램입니다.
+기본적으로 아래와 같은 출력을 만들어 냅니다:

 [ripgrep]: https://github.com/BurntSushi/ripgrep

@@ -201,7 +188,7 @@ src/components/span.rs
 6:    Span::default()
 ```

-But given `--json` it will print:
+그런데 `--json` 옵션을 주면 아래와 같이 출력됩니다:

 ```console
 $ rg default --json
@@ -214,59 +201,59 @@ $ rg default --json
 {"data":{"elapsed_total":{"human":"0.006995s","nanos":6994920,"secs":0},"stats":{"bytes_printed":533,"bytes_searched":11285,"elapsed":{"human":"0.000160s","nanos":159647,"secs":0},"matched_lines":2,"matches":2,"searches":2,"searches_with_match":2}},"type":"summary"}
 ```

-As you can see,
-each JSON document is an object (map) containing a `type` field.
-This would allow us to write a simple frontend for `rg`
-that reads these documents as they come in and show the matches
-(as well the files they are in)
-even while _ripgrep_ is still searching.
+보시다시피 각 JSON 문서는 `type` 필드를 포함하는 객체(맵)입니다.
+이를 통해 `rg`를 위한 간단한 프론트엔드를 작성할 수 있습니다.
+이 프론트엔드는 문서가 주어질 때마다 내용을 읽고,
+일치하는 부분(또는 일치하는 파일)을 표시해줍니다.
+이 과정은 심지어 ripgrep이 여전히 검색 중일 때도 가능합니다.

 <aside>

-**Note:**
-This is how Visual Studio Code uses _ripgrep_ for its code search.
+**참고:**
+Visual Studio Code가 코드를 검색할 때 ripgrep을 이렇게 사용합니다.

 </aside>

-## How to deal with input piped into us
+## 파이프된 입력을 다루는 방법

-Let's say we have a program that reads the number of words in a file:
+파일의 단어수를 세는 프로그램이 있다고 생각해봅시다:

 ``` rust,ignore
 {{#include machine-communication-wc.rs}}
 ```

-It takes the path to a file, reads it line by line, and counts the number of
-words separated by a space.
+이 프로그램은 파일의 경로르 받아 라인별로 읽고 공백으로 구분된
+단어의 개수를 셉니다.

-When you run it, it outputs the total words in the file:
+프로그램을 실행하면 파일에 있는 총 단어수가 출력됩니다:

 ``` console
 $ cargo run README.md
 Words in README.md: 47
 ```

-But what if we wanted to count the number of words piped into the program?
-Rust programs can read data passed in via stdin with the with [the Stdin
-struct](https://doc.rust-lang.org/std/io/struct.Stdin.html) which you can
-obtain via [the stdin function](https://doc.rust-lang.org/std/io/fn.stdin.html)
-from the standard library. Similar to reading the lines of a file, it can read
-the lines from stdin.
+이 프로그램이 파이프로 전달받은 파일의 단어수를 세도록 하려면 어떻게 해야 할까요?
+러스트 프로그램은 [Stdin 구조체](https://doc.rust-lang.org/std/io/struct.Stdin.html)를
+통해 전달받은 데이터를 읽을 수 있습니다. 이 구조체는
+표준 라이브러리의 [stdin 함수](https://doc.rust-lang.org/std/io/fn.stdin.html)를
+통해 얻을 수 있습니다.
+파일의 라인을 읽는 것처럼 stdin의 라인을 읽을 수 있습니다.

-Here's a program that counts the words of what's piped in via stdin
+아래는 stdin을 통해 파이프된 데이터의 단어수를 세는 프로그램입니다:

 ``` rust,ignore
 {{#include machine-communication-stdin.rs}}
 ```

-If you run that program with text piped in, with `-` representing the intent to
-read from `stdin`, it'll output the word count:
+만약 텍스트를 파이프로 전달하여 프로그램을 실행할 때는, `-`가
+`stdin`으로부터 데이터를 읽어들인다는 것을 의미합니다.
+이 프로그램은 단어수를 출력합니다:

 ``` console
 $ echo "hi there friend" | cargo run -- -
 Words from stdin: 3
 ```

-It requires that stdin is not interactive because we're expecting input that's
-piped through to the program, not text that's typed in at runtime. If stdin is
-a tty, it outputs the help docs so that it's clear why it doesn't work.
+이 프로그램은 런타임에 입력된 텍스트가 아닌, 파이프된 입력을 예상하기 때문에
+인터랙티브하지 않은 stdin을 요구합니다. 만약 stdin이 tty라면
+프로그램은 작동하지 않는 이유를 알려주기 위해 도움말 문서를 출력합니다.
diff --git a/src/in-depth/machine-communication.rs b/src/in-depth/machine-communication.rs
index 05bd62a..9ecc0d5 100644
--- a/src/in-depth/machine-communication.rs
+++ b/src/in-depth/machine-communication.rs
@@ -1,10 +1,10 @@
 use clap::Parser;
 use serde_json::json;

-/// Search for a pattern in a file and display the lines that contain it.
+/// 파일에서 패턴을 찾고 해당하는 라인을 보여준다.
 #[derive(Parser)]
 struct Cli {
-    /// Output JSON instead of human readable messages
+    /// 사람이 읽을 수 있는 메시지 대신 JSON 출력
     #[arg(long = "json")]
     json: bool,
 }
diff --git a/src/in-depth/signals-ctrlc.rs b/src/in-depth/signals-ctrlc.rs
index 8fc807f..e17092c 100644
--- a/src/in-depth/signals-ctrlc.rs
+++ b/src/in-depth/signals-ctrlc.rs
@@ -6,7 +6,7 @@ fn main() {
     })
     .expect("Error setting Ctrl-C handler");

-    // Following code does the actual work, and can be interrupted by pressing
-    // Ctrl-C. As an example: Let's wait a few seconds.
+    // 다음 코드는 실제로 동작하며, Ctrl-C로 인터럽트될 수 있다.
+    // 이 예시에서는 몇 초간 기다린다.
     thread::sleep(Duration::from_secs(2));
 }
diff --git a/src/in-depth/signals-hooked.rs b/src/in-depth/signals-hooked.rs
index 958da3b..c6543ef 100644
--- a/src/in-depth/signals-hooked.rs
+++ b/src/in-depth/signals-hooked.rs
@@ -10,8 +10,8 @@ fn main() -> Result<(), Box<dyn Error>> {
         }
     });

-    // Following code does the actual work, and can be interrupted by pressing
-    // Ctrl-C. As an example: Let's wait a few seconds.
+    // 다음 코드는 실제로 동작하며, Ctrl-C로 인터럽트될 수 있다.
+    // 이 예시에서는 몇 초간 기다린다.
     thread::sleep(Duration::from_secs(2));

     Ok(())
diff --git a/src/in-depth/signals.md b/src/in-depth/signals.md
index 780b34d..90d1057 100644
--- a/src/in-depth/signals.md
+++ b/src/in-depth/signals.md
@@ -1,64 +1,60 @@
-# Signal handling
+# 시그널 다루기

-Processes
-like command line applications
-need to react to signals sent by the operating system.
-The most common example is probably <kbd>Ctrl</kbd>+<kbd>C</kbd>,
-the signal that typically tells a process to terminate.
-To handle signals in Rust programs
-you need to consider how you can receive these signals
-as well as how you can react to them.
+커맨드라인 애플리케이션과 같은 프로세스는
+운영체제가 보낸 시그널에 반응해야 합니다.
+시그널의 가장 흔한 예시는 아마도, 일반적으로 프로세스를 종료시킬 때
+쓰는 <kbd>Ctrl</kbd>+<kbd>C</kbd>일 것 입니다.
+러스트 프로그램에서 시그널을 다루기 위해서는
+시그널에 반응하는 방법뿐 아니라
+시그널을 수신하는 방법에 대해서도 고민해 봐야 합니다.

 <aside>

-**Note:**
-If your applications does not need to gracefully shutdown,
-the default handling is fine
-(i.e. exit immediately
-and let the OS cleanup resources like open file handles).
-In that case:
-No need to do what this chapter tells you!
-
-However,
-for applications that need to clean up after themselves,
-this chapter is very relevant!
-For example,
-if your application needs to
-properly close network connections
-(saying "good bye" to the processes at the other end),
-remove temporary files,
-or reset system settings,
-read on.
+**참고:**
+애플리케이션을 우아하게 종료할 필요가 없다면
+기본적인 처리 방식도 괜찮습니다.
+(즉, 프로그램을 즉시 종료하고, 파일 핸들러와
+같은 리소스는 OS가 정리하도록 하는 식입니다.)
+그런 경우에는 이 챕터의 내용을 따를 필요가 없습니다!
+
+그러나, 애플리케이션이 종료되기 전에 스스로 리소스를
+정리해야 하는 경우에는 이 챕터가 매우 중요합니다!
+예를 들어,
+애플리케이션이 적절하게 네트워크 커넥션을 닫아야 한다거나,
+(종료 전에 다른 프로세스에게 "good bye"를 보내는 동작)
+임시 파일을 지워야 한다거나,
+시스템 설정을 초기화하는 것과 같은
+절차가 필요할 수 있습니다.

 </aside>

-## Differences between operating systems
+## 운영체제간 차이점

-On Unix systems
-(like Linux, macOS, and FreeBSD)
-a process can receive [signals].
-It can either react to them
-in a default (OS-provided) way,
-catch the signal and handle them in a program-defined way,
-or ignore the signal entirely.
+유닉스 시스템(리눅스, macOS, FreeBSD 등)에서
+프로세스는 [시그널]을 받을 수 있습니다.
+프로세스는 시그널을 받아서 프로그램이 정의한 방식으로
+시그널을 처리하는 기본적인 방법(OS가 제공)으로
+시그널에 반응할 수도 있고,
+시그널을 통째로 무시할 수도 있습니다.

-[signals]: https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html
+[시그널]: https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html

-Windows does not have signals.
-You can use [Console Handlers]
-to define callbacks that get executed when an event occurs.
-There is also [structured exception handling]
-which handles all the various types of system exceptions such as division by zero, invalid access exceptions, stack overflow, and so on
+윈도우즈에는 시그널이 없습니다.
+대신 [콘솔 핸들러]를 이용하여 이벤트가 발생했을 때
+실행되는 콜백을 정의할 수 있습니다.
+또한 윈도우즈에는 0으로 나누기, 잘못된 접근, 스택오버플로우 등 모든 종류의
+시스템 예외를 처리할 수 있는 [구조적 예외 처리]도 있습니다.

-[Console Handlers]: https://docs.microsoft.com/en-us/windows/console/console-control-handlers
-[structured exception handling]: https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling
+[콘솔 핸들러]: https://learn.microsoft.com/ko-kr/windows/console/console-control-handlers
+[구조적 예외 처리]: https://docs.microsoft.com/ko-kr/windows/desktop/debug/structured-exception-handling

-## First off: Handling Ctrl+C
+## Ctrl+C 다루기

-The [ctrlc] crate does just what the name suggests:
-It allows you to react to the user pressing <kbd>Ctrl</kbd>+<kbd>C</kbd>,
-in a cross-platform way.
-The main way to use the crate is this:
+[ctrlc] 크레이트는 이름 그대로의 일을 합니다.
+[ctrlc]는 다양한 플랫폼에 대해 사용자가
+<kbd>Ctrl</kbd>+<kbd>C</kbd>을 눌렀을 때
+프로그램이 반응할 수 있도록 만들어 줍니다.
+[ctrlc]의 주요 사용법은 아래와 같습니다:

 [ctrlc]: https://crates.io/crates/ctrlc

@@ -66,31 +62,31 @@ The main way to use the crate is this:
 {{#include signals-ctrlc.rs}}
 ```

-This is, of course, not that helpful:
-It only prints a message but otherwise doesn't stop the program.
+물론 이렇게 하면 별 도움이 되지 않습니다.
+메시지를 출력할 뿐 프로그램을 종료시키지는 않으니까요.

-In a real-world program,
-it's a good idea to instead set a variable in the signal handler
-that you then check in various places in your program.
-For example,
-you can set an `Arc<AtomicBool>`
-(a boolean shareable between threads)
-in your signal handler,
-and in hot loops,
-or when waiting for a thread,
-you periodically check its value
-and break when it becomes true.
+실제 프로그램의 경우,
+시그널 핸들러에서 변수를 설정해
+프로그램 곳곳에서 상태를 체크하는 것이 좋습니다.
+예를 들어,
+시그널 핸들러에서 `Arc<AtomicBool>`
+(스레드 간에 공유할 수 있는 불리언 타입)
+변수를 설정하면, 루프(hot loop)를 돌거나
+스레드를 대기할 때 그 값을 주기적으로
+체크하면서 true가 되면 프로그램을
+종료하도록 할 수 있습니다.

-## Handling other types of signals
+## 다른 시그널 다루기

-The [ctrlc] crate only handles <kbd>Ctrl</kbd>+<kbd>C</kbd>,
-or, what on Unix systems would be called `SIGINT` (the "interrupt" signal).
-To react to more Unix signals,
-you should have a look at [signal-hook].
-Its design is described in [this blog post][signal-hook-post],
-and it is currently the library with the widest community support.
+[ctrlc] 크레이트는 <kbd>Ctrl</kbd>+<kbd>C</kbd>,
+혹은 유닉스 시스템에서 `SIGINT` ("인터럽트" 시그널)라고 불리는
+시그널만 다룰 수 있습니다.
+더 많은 유닉스 시그널에 반응하기 위해서는
+[signal-hook]를 사용해야 합니다.
+[signal-hook]의 설계는 [이 블로그 글][signal-hook-post]에
+설명되어 있으며, 현재 가장 광범위한 커뮤니티 지원을 받는 라이브러리입니다.

-Here's a simple example:
+여기 간단한 예시가 있습니다:

 ```rust,ignore
 {{#include signals-hooked.rs}}
@@ -98,17 +94,15 @@ Here's a simple example:

 [signal-hook-post]: https://vorner.github.io/2018/06/28/signal-hook.html

-## Using channels
+## 채널 사용하기

-Instead of setting a variable
-and having other parts of the program check it,
-you can use channels:
-You create a channel into which the signal handler emits a value
-whenever the signal is received.
-In your application code you use
-this and other channels
-as synchronization points between threads.
-Using [crossbeam-channel] it would look something like this:
+변수를 설정하고, 프로그램이 그 변수를 체크하도록 만드는 대신
+채널을 사용할 수 있습니다:
+채널을 만들면 시그널을 수신할 때마다 시그널 핸들러가
+채널로 값을 내보내 줍니다.
+애플리케이션 코드에서는 한 채널과
+다른 채널을 스레드 간의 동기화 지점으로 사용하게 됩니다.
+[crossbeam-channel]을 사용하면 아래와 같은 모습이 됩니다:

 [crossbeam-channel]: https://crates.io/crates/crossbeam-channel

@@ -116,26 +110,27 @@ Using [crossbeam-channel] it would look something like this:
 {{#include signals-channels.rs}}
 ```

-## Using futures and streams
+## 퓨쳐(futures)와 스트림 사용하기

-If you are using [tokio],
-you are most likely already writing your application
-with asynchronous patterns and an event-driven design.
-Instead of using crossbeam's channels directly,
-you can enable signal-hook's `tokio-support` feature.
-This allows you to call [`.into_async()`]
-on signal-hook's `Signals` types
-to get a new type that implements `futures::Stream`.
+[tokio]를 사용하고 있다면,
+여러분은 이미 비동기 패턴과 이벤트 주도 설계를 적용하여
+애플리케이션을 작성하고 있을 확률이 높습니다.
+이때는 crossbeam의 채널을 직접 사용하지 않고
+[signal-hook]의 `tokio-support` 기능을 사용할 수 있습니다.
+이 기능을 이용하면 [signal-hook]의 `Signals` 타입에 대해
+[`.into_async()`]를 호출하여 `futures::Stream`을 구현하는
+새로운 타입을 얻을 수 있습니다.

 [signal-hook]: https://crates.io/crates/signal-hook
 [tokio]: https://tokio.rs/
 [`.into_async()`]: https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async

-## What to do when you receive another Ctrl+C while you're handling the first Ctrl+C
+## 첫 Ctrl+C 시그널을 처리하는 도중 또 다른 Ctrl+C 시그널을 수신했을 때
+
+사용자가 <kbd>Ctrl</kbd>+<kbd>C</kbd>를 누르면
+여러분의 프로그램은 몇 초 뒤 종료되거나
+진행 상황을 알려줄 것입니다.
+만약 그렇지 않으면 사용자는
+<kbd>Ctrl</kbd>+<kbd>C</kbd>을 한 번 더 누를 것입니다.
+이때 일반적인 동작은 애플리케이션을 즉시 종료하는 것입니다.

-Most users will press <kbd>Ctrl</kbd>+<kbd>C</kbd>,
-and then give your program a few seconds to exit,
-or tell them what's going on.
-If that doesn't happen,
-they will press <kbd>Ctrl</kbd>+<kbd>C</kbd> again.
-The typical behavior is to have the application quit immediately.
diff --git a/src/resources/README.md b/src/resources/README.md
index 7f8b007..b20e2dd 100644
--- a/src/resources/README.md
+++ b/src/resources/README.md
@@ -1,35 +1,35 @@
-# Resources
+# 자료

-Collaboration / help
+협업 / 도움
 - [cli-and-tui Discord Channel](https://discord.com/channels/273534239310479360/943315667430563862)

-## Crates referenced in this book
+## 이 책에서 참조한 크레이트

-- [anyhow](https://crates.io/crates/anyhow) - provides `anyhow::Error` for easy error handling
-- [assert_cmd](https://crates.io/crates/assert_cmd) - simplifies integration testing of CLIs
-- [assert_fs](https://crates.io/crates/assert_fs) - Setup input files and test output files
-- [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) - adds a `--verbose` flag to clap CLIs
-- [clap](https://crates.io/crates/clap) - command line argument parser
-- [confy](https://crates.io/crates/confy) - boilerplate-free configuration management
-- [crossbeam-channel](https://crates.io/crates/crossbeam-channel) - provides multi-producer multi-consumer channels for message passing
-- [ctrlc](https://crates.io/crates/ctrlc) - easy ctrl-c handler
-- [env_logger](https://crates.io/crates/env_logger) - implements a logger configurable via environment variables
-- [exitcode](https://crates.io/crates/exitcode) - system exit code constants
-- [human-panic](https://crates.io/crates/human-panic) - panic message handler
-- [indicatif](https://crates.io/crates/indicatif) - progress bars and spinners
-- [is-terminal](https://crates.io/crates/is-terminal) - detected whether application is running in a tty
-- [log](https://crates.io/crates/log) - provides logging abstracted over implementation
-- [predicates](https://crates.io/crates/predicates) - implements boolean-valued predicate functions
-- [proptest](https://crates.io/crates/proptest) - property testing framework
-- [serde_json](https://crates.io/crates/serde_json) - serialize/deserialize to JSON
-- [signal-hook](https://crates.io/crates/signal-hook) - handles UNIX signals
-- [tokio](https://crates.io/crates/tokio) - asynchronous runtime
-- [wasm-pack](https://crates.io/crates/wasm-pack) - tool for building WebAssembly
+- [anyhow](https://crates.io/crates/anyhow) - 쉬운 에러 처리를 위한 `anyhow::Error` 제공
+- [assert_cmd](https://crates.io/crates/assert_cmd) - CLI 통합 테스트 간소화
+- [assert_fs](https://crates.io/crates/assert_fs) - 입력 파일 설정 및 출력 파일 테스트
+- [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) - clap CLI에 `--verbose` 플래그 추가
+- [clap](https://crates.io/crates/clap) - 커맨드라인 인자 파서
+- [confy](https://crates.io/crates/confy) - 보일러플레이트 없는 설정 관리
+- [crossbeam-channel](https://crates.io/crates/crossbeam-channel) - 메시지 패싱을 위한 다중 생산자, 다중 소비자 채널 제공
+- [ctrlc](https://crates.io/crates/ctrlc) - 쉬운 ctrl-c 핸들러
+- [env_logger](https://crates.io/crates/env_logger) - 환경 변수를 통해 설정 가능한 로거 구현
+- [exitcode](https://crates.io/crates/exitcode) - 시스템 종료 코드 상수
+- [human-panic](https://crates.io/crates/human-panic) - 패닉 메시지 핸들러
+- [indicatif](https://crates.io/crates/indicatif) - 프로그래스 바와 스피너
+- [is-terminal](https://crates.io/crates/is-terminal) - 애플리케이션이 tty에서 실행 중인지 감지
+- [log](https://crates.io/crates/log) - 구현에 대한 로그 추상화 제공
+- [predicates](https://crates.io/crates/predicates) - 불리언 값으로 평가되는 예측 함수 구현
+- [proptest](https://crates.io/crates/proptest) - 속성 기반 테스트 프레임워크
+- [serde_json](https://crates.io/crates/serde_json) - JSON 직렬화/역직렬화
+- [signal-hook](https://crates.io/crates/signal-hook) - UNIX 시그널 처리
+- [tokio](https://crates.io/crates/tokio) - 비동기 런타임
+- [wasm-pack](https://crates.io/crates/wasm-pack) - WebAssembly 빌드를 위한 도구

-## Other crates
+## 다른 크레이트

-Due to the constantly-changing landscape of Rust crates, a good place to find
-crates is the [lib.rs](https://lib.rs) crate index, including:
+러스트 크레이트는 수시로 변화하기 때문에, 크레이트를 찾는 좋은 장소로는
+[lib.rs](https://lib.rs) 크레이트 인덱스가 있습니다. 여기에는 아래와 같은 내용이 있습니다:
 - [Command-line interface](https://lib.rs/command-line-interface)
 - [Configuration](https://lib.rs/config)
 - [Database interfaces](https://lib.rs/database)
@@ -38,6 +38,6 @@ crates is the [lib.rs](https://lib.rs) crate index, including:
 - [HTTP Client](https://lib.rs/web-programming/http-client)
 - [Operating systems](https://lib.rs/os)

-Other resources:
+다른 자료:
 - [Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)
 - [rosetta-rs](https://github.com/rosetta-rs)
diff --git a/src/tutorial/README.md b/src/tutorial/README.md
index f7d2bda..c43a82a 100644
--- a/src/tutorial/README.md
+++ b/src/tutorial/README.md
@@ -1,59 +1,49 @@
-# Learning Rust by Writing a Command Line App in 15 Minutes
+# 15분 안에 커맨드라인 앱을 작성하며 러스트 배우기

-This tutorial will guide you through writing
-a CLI (command line interface) application
-in [Rust].
-It will take you roughly fifteen minutes
-to get to a point where you have a running program
-(around chapter 1.3).
-After that, we'll continue to tweak our program
-until we reach a point where we can ship our little tool.
+이 튜토리얼에서는 러스트로 CLI(command line interface) 애플리케이션을
+작성하는 방법에 대해 설명할 것입니다.
+프로그램을 실행하게 되는 지점(챕터 1.3쯤)까지 대략 15분 정도가 걸릴 수 있습니다.
+그 이후에는 이 작은 프로그램을 배포할 수 있을 때까지 프로그램을 수정해 나갈 것입니다.

-[Rust]: https://rust-lang.org/
+[러스트]: https://rust-lang.org/

-You’ll learn all the essentials about how to get going,
-and where to find more information.
-Feel free to skip parts you don't need to know right now
-or jump in at any point.
+여러분은 무엇을 어떻게 해야 하는지에 관한 필수적인 것들을 배우게 되며,
+어디에서 더 많은 정보를 찾을 수 있는지에 대해서도 배울 것입니다.
+당장 필요하지 않은 부분은 과감히 뛰어넘거나, 혹은 더 깊이 알아보세요.

 <aside>

-**Prerequisites:**
-This tutorial does not replace a general introduction to programming,
-and expects you to be familiar with a few common concepts.
-You should be comfortable with using a command line/terminal.
-If you already know a few other languages,
-this can be a good first contact with Rust.
-
-**Getting help:**
-If you at any point feel overwhelmed or confused with the features used,
-have a look at the extensive official documentation that comes with Rust,
-first and foremost the book,
-The Rust Programming Language.
-It comes with most Rust installations
-(`rustup doc`),
-and is available online on [doc.rust-lang.org].
+**선행지식:**
+이 튜토리얼은 프로그래밍에 대한 입문 과정을 다루지 않으며,
+여러분이 몇 가지 일반적인 개념에 친숙할 것이라고 가정합니다.
+여러분은 커맨드라인/터미널을 사용하는 데 어려움이 없어야 합니다.
+이미 다른 언어를 몇 개 알고 있다면, 이 튜토리얼은 러스트와의 좋은 첫 만남이 될 것입니다.
+
+**도움받기:**
+튜토리얼에서 사용하는 기능에 혼란스러움을 느끼거나, 압도된다면
+러스트가 제공하는 광범위한 공식 문서를 살펴보세요.
+가장 먼저 확인할 책은 The Rust Programming Language입니다.
+이는 대부분의 러스트 설치 과정(`rustup doc`)에 함께 제공되며,
+[doc.rust-lang.org]에서 온라인으로 찾아볼 수 있습니다.

 [doc.rust-lang.org]: https://doc.rust-lang.org

-You are also very welcome to ask questions –
-the Rust community is known to be friendly and helpful.
-Have a look at the [community page]
-to see a list of places where people discuss Rust.
+질문도 매우 환영합니다.
+러스트 커뮤니티는 친절하고, 유용한 것으로 알려져 있습니다.
+[커뮤니티 페이지]에서 러스트에 대해 논의하는 곳의 목록을 확인해 보세요.

-[community page]: https://www.rust-lang.org/community
+[커뮤니티 페이지]: https://www.rust-lang.org/community

 </aside>

-What kind of project do you want to write?
-How about we start with something simple:
-Let’s write a small `grep` clone.
-That is a tool that we can give a string and a path
-and it’ll print only the lines that contain the given string.
-Let’s call it `grrs` (pronounced “grass”).
+어떤 종류의 프로젝트를 하고 싶나요?
+먼저 간단한 것부터 시작해봅시다:
+우리는 작은 `grep` 클론을 작성해볼 것입니다.
+이 프로그램은 문자열과 경로를 받으면 주어진 문자열을 포함한
+라인만을 출력해주는 도구입니다.
+이를 `grrs`라고 부릅시다. ("그래스"라고 발음합니다.)

-In the end,
-we want to be able to run our tool like this:
+최종적으로 우리의 프로그램은 아래와 같이 실행합니다:

 ```console
 $ cat test.txt
@@ -68,15 +58,15 @@ $ grrs --help

 <aside class="note">

-**Note:**
-This book is written for [Rust 2018].
-The code examples can also be used on Rust 2015,
-but you might need to tweak them a bit;
-add `extern crate foo;` invocations, for example.
+**참고:**
+이 책은 [Rust 2018]을 위해 작성되었습니다.
+코드 예시는 Rust 2015에서도 사용할 수 있지만,
+예시를 조금 수정해야 할 수도 있습니다.
+가령, `extern crate foo;` 호출을 추가해야 할 수 있습니다.

-Make sure you run Rust 1.31.0 (or later)
-and that you have `edition = "2018"` set
-in the `[package]` section of your `Cargo.toml` file.
+Rust 1.31.0 (또는 그 이후 버전)을 사용하고 있는지 확인하고,
+`Cargo.toml` 파일의 `[package]` 섹션에
+`edition = "2018"`이 설정되어 있는지 확인하세요.

 [Rust 2018]: https://doc.rust-lang.org/edition-guide/index.html

diff --git a/src/tutorial/cli-args-clap.rs b/src/tutorial/cli-args-clap.rs
index a09d908..d481c0e 100644
--- a/src/tutorial/cli-args-clap.rs
+++ b/src/tutorial/cli-args-clap.rs
@@ -2,12 +2,12 @@

 use clap::Parser;

-/// Search for a pattern in a file and display the lines that contain it.
+/// 파일에서 패턴을 찾고 패턴을 포함한 라인을 보여준다.
 #[derive(Parser)]
 struct Cli {
-    /// The pattern to look for
+    /// 찾을 패턴
     pattern: String,
-    /// The path to the file to read
+    /// 읽을 파일 경로
     path: std::path::PathBuf,
 }

diff --git a/src/tutorial/cli-args.md b/src/tutorial/cli-args.md
index 4a8bb2b..282abb7 100644
--- a/src/tutorial/cli-args.md
+++ b/src/tutorial/cli-args.md
@@ -1,122 +1,116 @@
-# Parsing command-line arguments
+# 커맨드라인 인자 파싱하기

-A typical invocation of our CLI tool will look like this:
+우리가 만드는 CLI 도구의 일반적인 호출은 아래와 같이 보일 것입니다:

 ```console
 $ grrs foobar test.txt
 ```

-We expect our program to look at `test.txt`
-and print out the lines that contain `foobar`.
-But how do we get these two values?
+이때 프로그램은 `test.txt`를 살펴보고,
+`foobar`가 포함된 라인을 출력할 것입니다.
+그런데 저 두 값을 어떻게 얻을 수 있을까요?

-The text after the name of the program is often called
-the "command-line arguments",
-or "command-line flags"
-(especially when they look like `--this`).
-Internally, the operating system usually represents them
-as a list of strings –
-roughly speaking, they get separated by spaces.
+프로그램 이름 뒤에 나오는 텍스트는 보통
+"커맨드라인 인자"라고 부르며,
+`--this`와 같이 쓰일 때는 특히 "커맨드라인 플래그"라고도 부릅니다.
+내부적으로, 운영체제는 이를 문자열의 리스트로 나타냅니다.
+거칠게 말해서 이때 인자들은 공백으로 분리됩니다.

-There are many ways to think about these arguments,
-and how to parse them
-into something more easy to work with.
-You will also need to tell the users of your program
-which arguments they need to give
-and in which format they are expected.
+주어진 인자와 그 인자를 어떻게 파싱할지에 대해
+다양한 방향으로 생각해 볼 수 있습니다.
+또한 여러분은 프로그램 사용자에게
+어떤 인자를 어떤 형식으로 전달해야 하는지 알려줘야 합니다.

-## Getting the arguments
+## 인자 얻기

-The standard library contains the function
-[`std::env::args()`] that gives you an [iterator] of the given arguments.
-The first entry (at index `0`) will be the name your program was called as (e.g. `grrs`),
-the ones that follow are what the user wrote afterwards.
+표준 라이브러리에는 주어진 인자의 [이터레이터]를 제공하는
+[`std::env::args()`] 함수가 있습니다.
+첫 엔트리(`0`번 인덱스)는 프로그램의 이름입니다. (예를 들어 `grrs`.)
+이후 인자는 사용자가 입력하는 값이 됩니다.

 [`std::env::args()`]: https://doc.rust-lang.org/1.39.0/std/env/fn.args.html
-[iterator]: https://doc.rust-lang.org/1.39.0/std/iter/index.html
+[이터레이터]: https://doc.rust-lang.org/1.39.0/std/iter/index.html

-Getting the raw arguments this way is quite easy (in file `src/main.rs`, after `fn main() {`):
+이 방식으로 인자를 그대로 얻기는 매우 쉽습니다 (`src/main.rs` 파일에서 `fn main() {` 다음 부분):

 ```rust,ignore
 {{#include cli-args-struct.rs:10:11}}
 ```

-## CLI arguments as data type
+## 데이터 타입으로서의 CLI 인자

-Instead of thinking about them as a bunch of text,
-it often pays off to think of CLI arguments as a custom data type
-that represents the inputs to your program.
+주어진 인자들을 텍스트의 묶음으로 취급하는 대신,
+CLI 인자를 프로그램의 입력을 표현하는
+임의의 데이터 타입으로 생각해 볼 수 있습니다.

-Look at `grrs foobar test.txt`:
-There are two arguments,
-first the `pattern` (the string to look for),
-and then the `path` (the file to look in).
+`grrs foobar test.txt`를 봅시다:
+여기에는 두 개의 인자가 있습니다.
+첫 번째로 `pattern` (찾을 문자열)이 있고,
+이어서 `path` (문자열을 찾을 파일)이 있습니다.

-What more can we say about them?
-Well, for a start, both are required.
-We haven't talked about any default values,
-so we expect our users to always provide two values.
-Furthermore, we can say a bit about their types:
-The pattern is expected to be a string,
-while the second argument is expected to be a path to a file.
+이것에 대해 무엇을 더 논의할 수 있을까요?
+프로그램을 시작하기 위해서는 두 인자가 모두 필요합니다.
+우리가 기본값을 지정한 적이 없으므로,
+사용자는 항상 두 값을 제공할 것이라고 예상할 수 있습니다.
+더 나아가, 인자의 타입에 대해 말할 수 있습니다:
+첫 번째 인자인 패턴은 문자열이 될 것이고,
+두 번째 인자는 파일의 경로가 될 것입니다.

-In Rust, it is common to structure programs around the data they handle, so this
-way of looking at CLI arguments fits very well. Let's start with this (in file
-`src/main.rs`, before `fn main() {`):
+러스트에서는 프로그램이 다루는 데이터를 중심으로 프로그램을 구성하는 것이 일반적이므로,
+이러한 방식으로 CLI 인자를 처리하는 것이 매우 적합합니다.
+이것부터 시작하겠습니다 (`src/main.rs` 파일에서 `fn main() {` 앞 부분):

 ```rust,ignore
 {{#include cli-args-struct.rs:3:7}}
 ```

-This defines a new structure (a [`struct`])
-that has two fields to store data in: `pattern`, and `path`.
+위 코드는 `pattern`과 `path` 두 필드에 데이터를 저장하는
+새로운 구조체([`struct`])를 정의힙니다.

 [`struct`]: https://doc.rust-lang.org/1.39.0/book/ch05-00-structs.html

 <aside>

-**Note:**
-[`PathBuf`] is like a [`String`] but for file system paths that work cross-platform.
+**참고:**
+[`PathBuf`]는 [`String`]과 비슷하지만, 크로스 플랫폼에서 동작하는 파일 시스템 경로를 위해 사용합니다.

 [`PathBuf`]: https://doc.rust-lang.org/1.39.0/std/path/struct.PathBuf.html
 [`String`]: https://doc.rust-lang.org/1.39.0/std/string/struct.String.html

 </aside>

-Now, we still need to get the actual arguments our program got into this form.
-One option would be to manually parse the list of strings we get from the operating system
-and build the structure ourselves.
-It would look something like this:
+인자를 앞서 정의한 구조체 형태로 만들기 위해서는 프로그램에 입력된 실제 인자를 얻어야 합니다.
+한 가지 방법은 운영체제로부터 얻은 문자열 리스트를 하나씩 파싱하고, 구조체를 직접 만드는 것입니다.
+이는 아래와 같이 할 수 있습니다:

 ```rust,ignore
 {{#include cli-args-struct.rs:10:15}}
 ```

-This works, but it's not very convenient.
-How would you deal with the requirement to support
-`--pattern="foo"` or `--pattern "foo"`?
-How would you implement `--help`?
+위 코드는 잘 동작하기는 하지만, 별로 편리하지 않습니다.
+이 방법으로 `--pattern="foo"`나 `--pattern "foo"`와 같은 요구사항은 어떻게 지원할 수 있을까요?
+`--help`는 어떻게 구현해야 할까요?

-## Parsing CLI arguments with Clap
+## Clap으로 CLI 인자 파싱하기

-A much nicer way is to use one of the many available libraries.
-The most popular library for parsing command-line arguments
-is called [`clap`].
-It has all the functionality you'd expect,
-including support for sub-commands, [shell completions], and great help messages.
+더 좋은 방법은 다양한 라이브러리 중 하나를 사용하는 것입니다.
+커맨드라인 인자를 파싱하는 데 가장 인기있는 라이브러리는
+[`clap`]입니다.
+[`clap`]은 서브 커맨드, [쉘 자동완성], 도움말 메시지 등,
+여러분이 생각하는 모든 기능을 지원합니다.

 [`clap`]: https://docs.rs/clap/
-[shell completions]: https://docs.rs/clap_complete/
+[쉘 자동완성]: https://docs.rs/clap_complete/

-Let's first import `clap` by adding
-`clap = { version = "4.0", features = ["derive"] }` to the `[dependencies]` section
-of our `Cargo.toml` file.
+먼저 `Cargo.toml` 파일의 `[dependencies]` 섹션에
+`clap = { version = "4.0", features = ["derive"] }`을 추가해
+`clap`을 가져와 봅시다.

-Now, we can write `use clap::Parser;` in our code,
-and add `#[derive(Parser)]` right above our `struct Cli`.
-Let's also write some documentation comments along the way.
+이제 우리의 코드에 `use clap::Parser;`를 추가하고,
+`struct Cli` 바로 위에 `#[derive(Parser)]`를 작성합니다.
+그리고 문서화 주석도 작성해 봅시다.

-It’ll look like this (in file `src/main.rs`, before `fn main() {`):
+아래와 같이 하면 됩니다 (`src/main.rs` 파일의 `fn main() {` 앞 부분):

 ```rust,ignore
 {{#include cli-args-clap.rs:3:12}}
@@ -124,54 +118,51 @@ It’ll look like this (in file `src/main.rs`, before `fn main() {`):

 <aside class="node">

-**Note:**
-There are a lot of custom attributes you can add to fields.
-For example,
-to say you want to use this field for the argument after `-o` or `--output`,
-you'd add `#[arg(short = 'o', long = "output")]`.
-For more information,
-see the [clap documentation][`clap`].
+**참고:**
+필드에 추가할 수 있는 수많은 커스텀 어트리뷰트가 있습니다.
+예를 들어, 어떤 필드를 `-o` 또는 `--output` 뒤에 오는 인자를 위해 사용하고 싶다면
+`#[arg(short = 'o', long = "output")]`를 추가하면 됩니다.
+더 자세한 정보는 [clap 문서][`clap`]를 확인해보세요.

 </aside>

-Right below the `Cli` struct our template contains its `main` function.
-When the program starts, it will call this function.
-The first line is:
+`Cli` 구조체 바로 아래에 `main` 함수가 있습니다.
+프로그램이 실행되면, 프로그램은 `main` 함수를 호출하게 됩니다.
+함수의 첫 줄은 아래와 같습니다:

 ```rust,ignore
 {{#include cli-args-clap.rs:14:16}}
 ```

-This will try to parse the arguments into our `Cli` struct.
+위 코드는 인자를 파싱해 `Cli` 구조체로 변환합니다.

-But what if that fails?
-That's the beauty of this approach:
-Clap knows which fields to expect,
-and what their expected format is.
-It can automatically generate a nice `--help` message,
-as well as give some great errors
-to suggest you pass `--output` when you wrote `--putput`.
+이때 문제가 생기면 어떻게 될까요?
+이 지점이 Clap을 사용하는 접근법의 아름다운 부분입니다.
+Clap은 어떤 필드가 주어져야 하는지,
+그 필드가 어떤 형식으로 주어져야 하는지 알고 있습니다.
+Clap은 자동으로 `--help` 메시지를 생성해 줄 뿐만 아니라,
+`--output`이 아닌 `--putput`을 입력한 사용자에게
+에러를 제공해 줍니다.

 <aside class="note">

-**Note:**
-The `parse` method is meant to be used in your `main` function.
-When it fails,
-it will print out an error or help message
-and immediately exit the program.
-Don't use it in other places!
+**참고:**
+`parse` 메서드는 `main` 함수에서 사용해야 합니다.
+만약 파싱에 실패한다면 `parse` 메서드는 에러나 도움말 메시지를 출력하고
+즉시 프로그램을 종료할 것입니다.
+다른 곳에서는 `parse` 메서드를 사용하지 마세요!

 </aside>

-## Wrapping up
+## 마무리

-Your code should now look like:
+여러분의 코드는 이제 아래와 같아야 합니다:

 ```rust,ignore
 {{#include cli-args-clap.rs}}
 ```

-Running it without any arguments:
+아무 인자 없이 실행하는 경우:

 ```console
 $ cargo run
@@ -187,7 +178,7 @@ USAGE:
 For more information try --help
 ```

-We can pass arguments when using `cargo run` directly by writing them after  `--`:
+`cargo run`을 실행할 때는 `--` 뒤에 인자를 전달할 수 있습니다.

 ```console
 $ cargo run -- some-pattern some-file
@@ -195,14 +186,12 @@ $ cargo run -- some-pattern some-file
      Running `target/debug/grrs some-pattern some-file`
 ```

-As you can see,
-there is no output.
-Which is good:
-That just means there is no error and our program ended.
+보다시피 프로그램은 아무것도 출력하지 않습니다.
+이는 오류 없이 프로그램이 종료되었다는 것을 의미합니다.

 <aside class="exercise">

-**Exercise for the reader:**
-Make this program output its arguments!
+**연습:**
+이 프로그램이 인자를 출력하도록 만들어 보세요!

 </aside>
diff --git a/src/tutorial/errors.md b/src/tutorial/errors.md
index 6992615..e65ee01 100644
--- a/src/tutorial/errors.md
+++ b/src/tutorial/errors.md
@@ -1,28 +1,22 @@
-# Nicer error reporting
+# 더 나은 에러 보고

-We all can do nothing but accept the fact that errors will occur.
-And in contrast to many other languages,
-it's very hard not to notice and deal with this reality
-when using Rust:
-As it doesn't have exceptions,
-all possible error states are often encoded in the return types of functions.
+우리는 모두 에러가 발생할 것이라는 사실을 받아들일 수밖에 없습니다.
+다른 언어들과 다르게, 러스트를 사용할 때는 이 현실을 무시하기가 쉽지 않습니다.
+러스트에는 예외가 없으며, 모든 발생 가능한 에러 상태는 보통 함수의 반환 타입으로 표현됩니다.

-## Results
+## Result

-A function like [`read_to_string`] doesn't return a string.
-Instead, it returns a [`Result`]
-that contains either
-a `String`
-or an error of some type
-(in this case [`std::io::Error`]).
+[`read_to_string`]과 같은 함수는 문자열을 반환하지 않습니다.
+대신, `String`이나 에러 타입 중 하나를 담은 [`Result`]를 반환합니다.
+(여기서 에러 타입은 [`std::io::Error`])

 [`read_to_string`]: https://doc.rust-lang.org/1.39.0/std/fs/fn.read_to_string.html
 [`Result`]: https://doc.rust-lang.org/1.39.0/std/result/index.html
 [`std::io::Error`]: https://doc.rust-lang.org/1.39.0/std/io/type.Result.html

-How do you know which it is?
-Since `Result` is an `enum`,
-you can use `match` to check which variant it is:
+어떤 타입이 들어있는지 어떻게 알 수 있을까요?
+`Result`는 `enum`이기 때문에,
+`match`를 이용해 확인할 수 있습니다.

 ```rust,no_run
 let result = std::fs::read_to_string("test.txt");
@@ -34,20 +28,19 @@ match result {

 <aside>

-**Note:**
-Not sure what enums are or how they work in Rust?
-[Check this chapter of the Rust book](https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html)
-to get up to speed.
+**참고:**
+enum이 무엇이고, 러스트에서 enum이 어떻게 동작하는지 잘 모르겠나요?
+그렇다면 [러스트 책의 이 챕터를 읽어보세요](https://doc.rust-lang.org/1.39.0/book/ch06-00-enums.html).

 </aside>

-## Unwrapping
+## Unwrap

-Now, we were able to access the content of the file,
-but we can't really do anything with it after the `match` block.
-For this, we'll need to somehow deal with the error case.
-The challenge is that all arms of a `match` block need to return something of the same type.
-But there's a neat trick to get around that:
+이제 우리는 파일 내용에 접근할 수 있지만,
+`match` 블록 이후로 실제 뭔가를 할 수는 없습니다.
+이를 위해서는 에러 케이스를 처리해야 합니다.
+이때 어려운 부분은 `match` 블록의 모든 분기가 같은 타입을 반환해야 한다는 점입니다.
+하지만 간단한 트릭이 있습니다:

 ```rust,no_run
 let result = std::fs::read_to_string("test.txt");
@@ -58,25 +51,23 @@ let content = match result {
 println!("file content: {}", content);
 ```

-We can use the String in `content` after the match block.
-If `result` were an error, the String wouldn't exist.
-But since the program would exit before it ever reached a point where we use `content`,
-it's fine.
+match 블록 이후에 `content`를 문자열로 사용할 수 있습니다.
+만약 `result`가 에러라면 문자열은 존재하지 않게 되지만,
+`result`를 사용하기 전에 프로그램이 종료될 것이기 때문에 문제가 없습니다.

-This may seem drastic,
-but it's very convenient.
-If your program needs to read that file and can't do anything if the file doesn't exist,
-exiting is a valid strategy.
-There's even a shortcut method on `Result`s, called `unwrap`:
+조금 과격해 보이지만, 매우 편리한 방법입니다.
+만약 파일을 읽는 프로그램이 파일이 존재하지 않는 경우 아무것도 할 수 없다면,
+프로그램 종료는 적합한 전략입니다.
+여기에는 `unwrap`이라는 `Result`의 단축 메서드도 있습니다:

 ```rust,no_run
 let content = std::fs::read_to_string("test.txt").unwrap();
 ```

-## No need to panic
+## 패닉할 필요 없습니다

-Of course, aborting the program is not the only way to deal with errors.
-Instead of the `panic!`, we can also easily write `return`:
+물론 프로그램 종료가 에러를 다루는 유일한 방법은 아닙니다.
+`panic!` 대신 단순히 `return`을 사용할 수 있습니다:

 ```rust,no_run
 # fn main() -> Result<(), Box<dyn std::error::Error>> {
@@ -89,12 +80,11 @@ let content = match result {
 # }
 ```

-This, however changes the return type our function needs.
-Indeed, there was something hidden in our examples all this time:
-The function signature this code lives in.
-And in this last example with `return`,
-it becomes important.
-Here's the _full_ example:
+그러나 이렇게 하려면 함수의 반환 타입을 변경해야 합니다.
+지금까지의 모든 예시에 실제로는 숨겨진 부분이 있었습니다.
+바로 이 코드가 속해 있는 함수 시그니처입니다.
+`return`이 있는 앞 예시에서 이것이 매우 중요해집니다.
+여기 전체 예시가 있습니다:

 ```rust,no_run
 fn main() -> Result<(), Box<dyn std::error::Error>> {
@@ -108,35 +98,33 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
 }
 ```

-Our return type is a `Result`!
-This is why we can write `return Err(error);` in the second match arm.
-See how there is an `Ok(())` at the bottom?
-It's the default return value of the function and means
-"Result is okay, and has no content".
+우리의 반환 타입은 `Result`입니다!
+덕분에 두 번째 match 분기에서 `return Err(error);`을 사용할 수 있습니다.
+맨 마지막에 `Ok(())`가 보이시나요?
+이는 함수의 기본 반환 값이며, "결과가 정상이고, 내용은 없다"라는 의미입니다.

 <aside>

-**Note:**
-Why is this not written as `return Ok(());`?
-It easily could be – this is totally valid as well.
-The last expression of any block in Rust is its return value,
-and it is customary to omit needless `return`s.
+**참고:**
+왜 `return Ok(());`라고 쓰지 않았을까요?
+`Ok(())`는 쉽게 사용할 수 있으며, 완전히 유효한 문법입니다.
+러스트에서는 어떤 블록에서든 마지막 표현식은 블록의 반환 값이며,
+`return`을 관례적으로 생략할 수 있습니다.

 </aside>

-## Question Mark
+## 물음표

-Just like calling `.unwrap()` is a shortcut
-for the `match` with `panic!` in the error arm,
-we have another shortcut for the `match` that `return`s in the error arm:
-`?`.
+`.unwrap()`을 호출하는 것은 `match`의 에러 분기에서
+`panic!`을 사용하는 것과 동일한 일종의 단축어입니다.
+또 다른 단축어로는 에러 분기의 `return`을 위한 `?`가 있습니다.

-That's right, a question mark.
-You can append this operator to a value of type `Result`,
-and Rust will internally expand this to something very similar to
-the `match` we just wrote.
+맞아요, 물음표입니다.
+`Result` 타입의 값에 이 연산자를 붙일 수 있고,
+러스트는 내부적으로 이 연산자를 우리가 작성한
+`match`와 매우 비슷한 것으로 확장해 줍니다.

-Give it a try:
+한번 해보세요:

 ```rust,no_run
 fn main() -> Result<(), Box<dyn std::error::Error>> {
@@ -146,86 +134,82 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {
 }
 ```

-Very concise!
+정말 간결하죠!

 <aside>

-**Note:**
-There are a few more things happening here
-that are not required to understand to work with this.
-For example,
-the error type in our `main` function is `Box<dyn std::error::Error>`.
-But we've seen above that `read_to_string` returns a [`std::io::Error`].
-This works because `?` expands to code that  _converts_ error types.
+**참고:**
+여기서 사용만 할 때는 알 필요가 없는 몇 가지 다른 일들이 일어납니다.
+예를 들어,
+`main` 함수의 에러 타입은 `Box<dyn std::error::Error>`입니다.
+하지만 앞서 봤듯이, `read_to_string`은 [`std::io::Error`]를 반환합니다.
+이것이 동작하는 이유는, `?`가 에러 타입을 변환하는 코드로 확장되기 때문입니다.

-`Box<dyn std::error::Error>` is also an interesting type.
-It's a `Box` that can contain _any_ type
-that implements the standard [`Error`][`std::error::Error`] trait.
-This means that basically all errors can be put into this box,
-so we can use `?` on all of the usual functions that return `Result`s.
+`Box<dyn std::error::Error>`는 흥미로운 타입입니다.
+`Box`는 표준 [`Error`][`std::error::Error`] 트레잇을 구현하는 타입이라면 _어떤 타입이든_ 담을 수 있습니다.
+즉, 기본적으로 모든 에러를 박스에 담을 수 있습니다.
+따라서 `Result`를 반환하는 모든 함수에서 `?`를 사용할 수 있습니다.

 [`std::error::Error`]: https://doc.rust-lang.org/1.39.0/std/error/trait.Error.html

 </aside>

-## Providing Context
+## 맥락 제공하기

-The errors you get when using `?` in your `main` function are okay,
-but they are not great.
-For example:
-When you run `std::fs::read_to_string("test.txt")?`
-but the file `test.txt` doesn't exist,
-you get this output:
+`main` 함수에서 `?`를 사용하여 에러를 받는 것은 괜찮지만,
+최선의 방법은 아닙니다.
+예를 들어:
+`std::fs::read_to_string("test.txt")?`를 실행할 때
+`test.txt`가 존재하지 않는다면,
+아래와 같은 출력을 보게 될 것입니다:

 ```text
 Error: Os { code: 2, kind: NotFound, message: "No such file or directory" }
 ```

-In cases where your code doesn't literally contain the file name,
-it would be very hard to tell which file was `NotFound`.
-There are multiple ways to deal with this.
+코드가 파일 이름을 포함하지 않는다면,
+어떤 파일이 `NotFound`인지 말해주기가 상당히 어렵습니다.
+이를 해결하는 여러 방법이 있습니다.

-For example, we can create our own error type,
-and then use that to build a custom error message:
+예를 들어, 우리만의 에러 타입을 만들 수 있습니다.
+그리고 커스텀 에러 메시지를 만들면 됩니다:

 ```rust,ignore
 {{#include errors-custom.rs}}
 ```

-Now,
-running this we'll get our custom error message:
+이제,
+프로그램을 실행하면 우리가 만든 커스텀 에러 메시지가 출력됩니다:

 ```text
 Error: CustomError("Error reading `test.txt`: No such file or directory (os error 2)")
 ```

-Not very pretty,
-but we can easily adapt the debug output for our type later on.
+그다지 예쁘지는 않지만,
+나중에 디버그 출력을 우리 타입에 맞게 적용할 수 있습니다.

-This pattern is in fact very common.
-It has one problem, though:
-We don't store the original error,
-only its string representation.
-The often used [`anyhow`] library has a neat solution for that:
-similar to our `CustomError` type,
-its [`Context`] trait can be used to add a description.
-Additionally, it also keeps the original error,
-so we get a "chain" of error messages pointing out the root cause.
+이러한 패턴은 실제로 매우 일반적입니다.
+그러나 원본 에러를 저장하지 않고 문자열만
+보여준다는 문제가 있습니다.
+이러한 문제를 해결하기 위해 주로 [`anyhow`] 라이브러리를 사용합니다.
+이를 통해 `CustomError` 타입처럼 [`Context`] 트레잇을 이용해 설명을 추가할 수 있습니다.
+더불어, 원본 에러를 저장함으로써 에러의 근본 원인을 알 수 있도록 해주는
+에러 메시지 "체인"을 제공합니다.

 [`anyhow`]: https://docs.rs/anyhow
 [`Context`]: https://docs.rs/anyhow/1.0/anyhow/trait.Context.html

-Let's first import the `anyhow` crate by adding
-`anyhow = "1.0"` to the `[dependencies]` section
-of our `Cargo.toml` file.
+먼저 `Cargo.toml` 파일의 `[dependencies]` 섹션에
+`anyhow = "1.0"`을 추가하여
+`anyhow` 크레이트를 가져옵니다.

-The full example will then look like this:
+전체 예시는 아래와 같습니다:

 ```rust,ignore
 {{#include errors-exit.rs}}
 ```

-This will print an error:
+실행하면 아래와 같이 에러가 출력됩니다:

 ```text
 Error: could not read file `test.txt`
diff --git a/src/tutorial/impl-draft.md b/src/tutorial/impl-draft.md
index e6d6853..f97cf31 100644
--- a/src/tutorial/impl-draft.md
+++ b/src/tutorial/impl-draft.md
@@ -1,15 +1,15 @@
-# First implementation of _grrs_
+# grrs의 첫 구현

-After the last chapter on command line arguments,
-we have our input data,
-and we can start to write our actual tool.
-Our `main` function only contains this line right now:
+지난 챕터에서 커맨드라인 인자를 다룬 뒤
+우리는 입력 데이터를 얻었고,
+실제 프로그램 작성을 시작할 수 있게 되었습니다.
+지금은 `main` 함수에 아래 한 줄만 있습니다:

 ```rust,ignore
 {{#include impl-draft.rs:15:15}}
 ```

-Let’s start by opening the file we got.
+이제 입력받은 파일을 열어봅시다.

 ```rust,ignore
 {{#include impl-draft.rs:16:16}}
@@ -17,46 +17,44 @@ Let’s start by opening the file we got.

 <aside>

-**Note:**
-See that [`.expect`] method here?
-This is a shortcut function to quit that will make the program exit immediately
-when the value (in this case the input file)
-could not be read.
-It's not very pretty,
-and in the next chapter on [Nicer error reporting]
-we will look at how to improve this.
+**참고:**
+여기서 [`.expect`] 메서드가 보이시나요?
+이 메서드는 값(여기서는 입력 파일)을 읽을 수 없을 때
+프로그램을 즉시 종료하는 단축 함수입니다.
+이는 별로 좋은 방법이 아니며,
+다음 챕터 [더 나은 에러 보고]에서
+어떻게 개선할 수 있을지 살펴보겠습니다.

 [`.expect`]: https://doc.rust-lang.org/1.39.0/std/result/enum.Result.html#method.expect
-[Nicer error reporting]:./errors.html
+[더 나은 에러 보고]:./errors.html

 </aside>

-Now, let’s iterate over the lines
-and print each one that contains our pattern:
+이제 파일의 각 라인을 순회하며
+주어진 패턴을 포함하고 있는 라인을 출력해 봅시다:

 ```rust,ignore
 {{#include impl-draft.rs:18:22}}
 ```

-## Wrapping up
+## 마무리

-Your code should now look like:
+여러분의 코드는 이제 아래와 같아야 합니다:

 ```rust,ignore
 {{#include impl-draft.rs}}
 ```

-Give it a try: `cargo run -- main src/main.rs` should work now!
+`cargo run -- main src/main.rs`으로 잘 동작하는지 확인해 보세요!

 <aside class="exercise">

-**Exercise for the reader:**
-This is not the best implementation:
-It will read the whole file into memory
-– however large the file may be.
-Find a way to optimize it!
-(One idea might be to use a [`BufReader`]
-instead of `read_to_string()`.)
+**연습:**
+이는 최선의 구현은 아닙니다.
+위 코드는 전체 파일을 읽어 메모리에 올리는데,
+큰 파일도 통째로 메모리에 올리게 됩니다.
+최적화할 수 있는 방법을 찾아보세요!
+(`read_to_string()` 대신 [`BufReader`]를 사용하는 방법을 생각해 볼 수 있습니다.)

 [`BufReader`]: https://doc.rust-lang.org/1.39.0/std/io/struct.BufReader.html

diff --git a/src/tutorial/impl-draft.rs b/src/tutorial/impl-draft.rs
index 7f38b9a..2aa04da 100644
--- a/src/tutorial/impl-draft.rs
+++ b/src/tutorial/impl-draft.rs
@@ -2,12 +2,12 @@

 use clap::Parser;

-/// Search for a pattern in a file and display the lines that contain it.
+/// 파일에서 패턴을 찾고 패턴을 포함한 라인을 보여준다.
 #[derive(Parser)]
 struct Cli {
-    /// The pattern to look for
+    /// 찾을 패턴
     pattern: String,
-    /// The path to the file to read
+    /// 읽을 파일 경로
     path: std::path::PathBuf,
 }

diff --git a/src/tutorial/output.md b/src/tutorial/output.md
index 901b85e..f0c9f58 100644
--- a/src/tutorial/output.md
+++ b/src/tutorial/output.md
@@ -1,68 +1,65 @@
-# Output
+# 출력

-## Printing "Hello World"
+## "Hello World" 출력하기

 ```rust
 println!("Hello World");
 ```

-Well, that was easy.
-Great, onto the next topic.
+쉽습니다. 좋아요, 다음 주제로 넘어가죠.

-## Using `println!`
+## `println!` 사용하기

-You can pretty much print all the things you like
-with the `println!` macro.
-This macro has some pretty amazing capabilities,
-but also a special syntax.
-It expects you to write a string literal as the first parameter,
-that contains placeholders that will be filled in
-by the values of the parameters that follow as further arguments.
+여러분이 출력하고 싶은 모든 것을 `println!` 매크로를
+통해 출력할 수 있습니다.
+이 매크로는 놀라운 기능을 갖추고 있으며,
+특수한 문법도 있습니다.
+`println!` 매크로에는 첫 파라미터로 문자열 리터럴을 전달해야 합니다.
+이 파라미터는 추가 인자의 값으로 채워질
+플레이스홀더(placeholder)를 포함해야 합니다.

-For example:
+예를 들어:

 ```rust
 let x = 42;
 println!("My lucky number is {}.", x);
 ```

-will print
+위 코드는 아래와 같은 출력을 냅니다:

 ```console
 My lucky number is 42.
 ```

-The curly braces (`{}`) in the string above is one of these placeholders.
-This is the default placeholder type
-that tries to print the given value in a human readable way.
-For numbers and strings this works very well,
-but not all types can do that.
-This is why there is also a "debug representation",
-that you can get by filling the braces of the placeholder like this: `{:?}`.
+위 코드에서 문자열에 있는 중괄호(`{}`)는 플레이스홀더 중 하나로,
+주어진 값을 사람이 읽을 수 있는 형태로 출력하는 기본 플레이스홀더입니다.
+숫자와 문자열에 대해 아주 잘 동작하지만, 모든 타입에 대해 동작하지는 않습니다.
+이는 "디버그 표현"이 있는 이유이기도 한데, `{:?}`처럼 플레이스홀더의 괄호를
+채워서 사용할 수 있습니다.

-For example,
+예를 들어:

 ```rust
 let xs = vec![1, 2, 3];
 println!("The list is: {:?}", xs);
 ```

-will print
+위 코드는 아래와 같은 출력을 냅니다:

 ```console
 The list is: [1, 2, 3]
 ```

-If you want your own data types to be printable for debugging and logging,
-you can in most cases add a `#[derive(Debug)]` above their definition.
+만약 자기만의 데이터 타입을 디버깅과 로깅을 위해 출력 가능하게 만들고 싶다면,
+대부분의 경우 타입 정의 위에 `#[derive(Debug)]`를 추가하면 됩니다.

 <aside>

-**Note:**
-"User-friendly" printing is done using the [`Display`] trait,
-debug output (human-readable but targeted at developers) uses the [`Debug`] trait.
-You can find more information about the syntax you can use in `println!`
-in the [documentation for the `std::fmt` module][std::fmt].
+**참고:**
+"사용자 친화적"인 출력을 위해서는 [`Display`] 트레잇을 사용하면 되고,
+디버그 출력(사람이 읽을 수 있지만 개발자를 위한 출력)을 위해서는 [`Debug`] 트레잇을 사용하면 됩니다.
+`println!`에서 사용할 수 있는 문법에 대해 더 자세히 알아보고 싶다면
+[`std::fmt` 모듈에 대한 문서][std::fmt]를 읽어보세요.

 [`Display`]: https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html
 [`Debug`]: https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html
@@ -70,31 +67,28 @@ in the [documentation for the `std::fmt` module][std::fmt].

 </aside>

-## Printing errors
+## 에러 출력하기

-Printing errors should be done via `stderr`
-to make it easier for users
-and other tools
-to pipe their outputs to files
-or more tools.
+에러는 `stderr`를 통해 출력해야 합니다.
+그래야 사용자나 다른 프로그램이 파이프를 통해
+프로그램의 출력을 파일이나 다른 프로그램에 전달하기
+쉬워집니다.

 <aside>

-**Note:**
-On most operating systems,
-a program can write to two output streams, `stdout` and `stderr`.
-`stdout` is for the program's actual output,
-while `stderr` allows errors and other messages to be kept separate from `stdout`.
-That way,
-output can be stored to a file or piped to another program
-while errors are shown to the user.
+**참고:**
+대부분의 운영체제에서,
+프로그램은 `stdout`과 `stderr` 두 개의 출력 스트림을 가지고 있습니다.
+`stdout`은 프로그램의 실제 출력의 위해 사용하는 반면,
+`stderr`은 `stdout`으로부터 분리된 별도의 에러나 메시지를 위해 사용합니다.
+이를 통해 사용자에게 에러를 보여주는 동시에 출력은 파일에 저장되도록 할 수 있고,
+또는 출력이 다른 프로그램에 파이프되도록 할 수도 있습니다.

 </aside>

-In Rust this is achieved
-with `println!` and `eprintln!`,
-the former printing to `stdout`
-and the latter to `stderr`.
+러스트에서는 이를 `println!`과 `eprintln!`으로 구현할 수 있으며,
+전자는 `stdout`으로 출력하고,
+후자는 `stderr`로 출력합니다.

 ```rust
 println!("This is information");
@@ -103,132 +97,127 @@ eprintln!("This is an error! :(");

 <aside>

-**Beware**: Printing [escape codes] can be dangerous,
-putting the user's terminal into a weird state.
-Always be careful when manually printing them!
+**주의**:
+[이스케이프 코드]를 출력하는 것은 위험할 수 있으며,
+사용자의 터미널을 이상한 상태에 빠지게 만들 수 있습니다.
+직접 [이스케이프 코드]를 출력할 때는 항상 조심하세요!

-[escape codes]: https://en.wikipedia.org/wiki/ANSI_escape_code
+[이스케이프 코드]: https://ko.wikipedia.org/wiki/ANSI_%EC%9D%B4%EC%8A%A4%EC%BC%80%EC%9D%B4%ED%94%84_%EC%BD%94%EB%93%9C

-Ideally you should be using a crate like `ansi_term`
-when dealing with raw escape codes
-to make your (and your user's) life easier.
+여러분(그리고 여러분의 사용자들)의 더 나은 삶을 위해,
+이스케이프 코드를 다룰 때는 `ansi_term`과 같은 크레이트를
+사용하는 것이 가장 좋습니다.

 </aside>

-## A note on printing performance
-
-Printing to the terminal is surprisingly slow!
-If you call things like `println!` in a loop,
-it can easily become a bottleneck in an otherwise fast program.
-To speed this up,
-there are two things you can do.
-
-First,
-you might want to reduce the number of writes
-that actually "flush" to the terminal.
-`println!` tells the system to flush to the terminal _every_ time,
-because it is common to print each new line.
-If you don't need that,
-you can wrap your `stdout` handle in a [`BufWriter`]
-which by default buffers up to 8 kB.
-(You can still call `.flush()` on this `BufWriter`
-when you want to print immediately.)
+## 출력 성능에 대한 참고사항
+
+터미널에 뭔가를 출력하는 것은 끔찍하게 느립니다!
+만약 루프에서 `println!`을 사용한다면,
+빠른 프로그램에서도 쉽게 보틀넥이 될 것입니다.
+성능을 높이기 위한 두 가지 대응 방법이 있습니다.
+
+첫 번째는, 터미널을 실제로 "플러시(flush)"하는
+쓰기 횟수를 줄이는 방법입니다.
+`println!`은 보통 새로운 라인에 내용을 출력하기 위해
+시스템에게 매번 터미널을 플러시해달라고 요청합니다.
+그럴 필요가 없다면, `stdout`을 [`BufWriter`]에서
+다루도록 래핑하면 됩니다. [`BufWriter`]는 기본적으로
+최대 8kB까지 버퍼링 할 수 있습니다.
+(즉시 출력을 하고 싶을 때는 `BufWriter`의
+`.flush()`를 호출하면 됩니다.)

 ```rust
 use std::io::{self, Write};

-let stdout = io::stdout(); // get the global stdout entity
-let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
-writeln!(handle, "foo: {}", 42); // add `?` if you care about errors here
+let stdout = io::stdout(); // 글로벌 stdout 엔티티를 얻는다
+let mut handle = io::BufWriter::new(stdout); // 선택사항: 버퍼로 다루도록 감싼다
+writeln!(handle, "foo: {}", 42); // 에러가 신경쓰인다면 여기에 `?`를 추가한다
 ```

-Second,
-it helps to acquire a lock on `stdout` (or `stderr`)
-and use `writeln!` to print to it directly.
-This prevents the system from locking and unlocking `stdout` over and over again.
+두 번째는,
+`stdout` (또는 `stderr`)에 대한 락(lock)을 획득하고
+`writeln!`을 이용해 직접 출력하는 방법입니다.
+이렇게 하면 시스템이 `stdout`을 매번 다시 잠그고 해제하는 것을 방지할 수 있습니다.

 ```rust
 use std::io::{self, Write};

-let stdout = io::stdout(); // get the global stdout entity
-let mut handle = stdout.lock(); // acquire a lock on it
-writeln!(handle, "foo: {}", 42); // add `?` if you care about errors here
+let stdout = io::stdout(); // 글로벌 stdout 엔티티를 얻는다
+let mut handle = stdout.lock(); // 락을 얻는다
+writeln!(handle, "foo: {}", 42);  // 에러가 신경쓰인다면 여기에 `?`를 추가한다
 ```

-You can also combine the two approaches.
+두 방법을 함께 사용할 수도 있습니다.

 [`BufWriter`]: https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html

-## Showing a progress bar
+## 프로그래스 바 보여주기

-Some CLI applications run less than a second,
-others take minutes or hours.
-If you are writing one of the latter types of programs,
-you might want to show the user that something is happening.
-For this, you should try to print useful status updates,
-ideally in a form that can be easily consumed.
+어떤 CLI 애플리케이션은 1초 이내에 실행되기도 하지만,
+어떤 애플리케이션은 수 분, 수 시간을 소요하기도 합니다.
+시간이 오래 걸리는 프로그램을 작성한다면,
+사용자에게 프로그램이 동작하고 있다는 것을 보여주고 싶을 수 있습니다.
+이를 위해서는 상태가 업데이트되고 있다는 정보를 사용하기
+쉬운 형태로 출력해줘야 합니다.

-Using the [indicatif] crate,
-you can add progress bars
-and little spinners to your program.
-Here's a quick example:
+[indicatif] 크레이트를 사용하면
+프로그램에 프로그래스 바와
+작은 스피너를 추가할 수 있습니다.
+여기 간단한 예시가 있습니다:

 ```rust,ignore
 {{#include output-progressbar.rs:1:9}}
 ```

-See the [documentation][indicatif docs]
-and [examples][indicatif examples]
-for more information.
+더 자세한 정보는
+[문서][indicatif docs]와 [예시][indicatif examples]를
+참고하세요.
+

 [indicatif]: https://crates.io/crates/indicatif
 [indicatif docs]: https://docs.rs/indicatif
 [indicatif examples]: https://github.com/console-rs/indicatif/tree/main/examples

-## Logging
-
-To make it easier to understand what is happening in our program,
-we might want to add some log statements.
-This is usually easy while writing your application.
-But it will become super helpful when running this program again in half a year.
-In some regard,
-logging is the same as using `println!`,
-except that you can specify the importance of a message.
-The levels you can usually use are _error_, _warn_, _info_, _debug_, and _trace_
-(_error_ has the highest priority, _trace_ the lowest).
-
-To add simple logging to your application,
-you'll need two things:
-The [log] crate (this contains macros named after the log level)
-and an _adapter_ that actually writes the log output somewhere useful.
-Having the ability to use log adapters is very flexible:
-You can, for example, use them to write logs not only to the terminal
-but also to [syslog], or to a central log server.
-
-[syslog]: https://en.wikipedia.org/wiki/Syslog
-
-Since we are right now only concerned with writing a CLI application,
-an easy adapter to use is [env_logger].
-It's called "env" logger because you can
-use an environment variable to specify which parts of your application
-you want to log
-(and at which level you want to log them).
-It will prefix your log messages with a timestamp
-and the module where the log messages come from.
-Since libraries can also use `log`,
-you easily configure their log output, too.
+## 로그
+
+프로그램에서 무슨 일이 일어나는지 보다 쉽게 이해하기 위해
+로그 구문을 추가하고 싶을 수 있습니다.
+보통 애플리케이션을 작성할 때 쉽게 로그를 남길 수 있습니다.
+로그는 반년 뒤에 프로그램을 다시 실행할 때 대단히 유용해집니다.
+한편, 로그를 남기는 것은 메시지의 중요도를 명시하는 것만 빼면
+`println!`을 사용하는 것과 같습니다.
+주로 사용하는 로그 레벨에는 _error_, _warn_, _info_, _debug_, _trace_ 가 있습니다. (_error_ 는 중요도가 가장 높고, _trace_ 는 가장 낮습니다.)
+
+애플리케이션에 간단한 로그를 남기기 위해서는
+[log] 크레이트 (로그 레벨의 이름을 딴 매크로 포함)와 로그 출력을
+작성할 때 유용한 어댑터가 필요합니다.
+로그 어댑터는 매우 유연하게 상용할 수 있습니다.
+예를 들어, 어댑터를 이용해 터미널이 아닌 [syslog]에 로그를 남길 수도 있고,
+아니면 중앙 로그 서버에 로그를 남길 수도 있습니다.
+
+[syslog]: https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%EB%A1%9C%EA%B7%B8
+
+우리는 CLI 애플리케이션을 작성하는 데만 집중하고 있으므로,
+당장 사용하기 쉬운 어댑터는 [env_logger]입니다.
+[env_logger]를 사용하면 애플리케이션의 어느 부분에 어떤 레벨의
+로그를 남길지 환경 변수를 통해 명시할 수 있기 때문에 이를 "env" 로거라고 합니다.
+[env_logger]는 로그 메시지 앞에 타임스탬프와
+로그를 남긴 모듈의 이름을 붙입니다.
+라이브러리도 `log`를 사용할 수 있기 때문에
+로그 출력을 쉽게 구성할 수 있습니다.

 [log]: https://crates.io/crates/log
 [env_logger]: https://crates.io/crates/env_logger

-Here's a quick example:
+여기 간단한 예시가 있습니다:

 ```rust,ignore
 {{#include output-log.rs}}
 ```

-Assuming you have this file as `src/bin/output-log.rs`,
-on Linux and macOS, you can run it like this:
+리눅스나 macOS에서 위 코드를 `src/bin/output-log.rs` 파일로 작성했다면,
+아래와 같이 실행할 수 있습니다:
 ```console
 $ env RUST_LOG=info cargo run --bin output-log
     Finished dev [unoptimized + debuginfo] target(s) in 0.17s
@@ -237,7 +226,7 @@ $ env RUST_LOG=info cargo run --bin output-log
 [2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
 ```

-In Windows PowerShell, you can run it like this:
+윈도우즈 파워쉘에서는 아래와 같이 실행할 수 있습니다:
 ```console
 $ $env:RUST_LOG="info"
 $ cargo run --bin output-log
@@ -247,7 +236,7 @@ $ cargo run --bin output-log
 [2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
 ```

-In Windows CMD, you can run it like this:
+윈도우즈 CMD에서는 아래와 같이 실행합니다:
 ```console
 $ set RUST_LOG=info
 $ cargo run --bin output-log
@@ -257,29 +246,25 @@ $ cargo run --bin output-log
 [2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
 ```

-`RUST_LOG` is the name of the environment variable
-you can use to set your log settings.
-`env_logger` also contains a builder
-so you can programmatically adjust these settings,
-and, for example, also show _info_ level messages by default.
+`RUST_LOG`는 로그 설정에
+사용하는 환경 변수의 이름입니다.
+`env_logger`에는 빌더가 있기 때문에
+프로그래밍적으로 로그를 설정할 수도 있으며,
+가령 기본적으로 _info_ 레벨 메시지가 출력됩니다.

-There are a lot of alternative logging adapters out there,
-and also alternatives or extensions to `log`.
-If you know your application will have a lot to log,
-make sure to review them,
-and make your users' life easier.
+이외에도 많은 로그 어댑터가 있으며,
+`log`를 대체하거나 확장할 수 있는 어댑터들이 있습니다.
+만약 애플리케이션에 많은 양의 로그가 필요할 것 같다면
+다른 것들을 검토해보고 사용자의 삶의 질을 높여주세요.

 <aside>

-**Tip:**
-Experience has shown that even mildly useful CLI programs can end up being used for years to come.
-(Especially if they were meant as a temporary solution.)
-If your application doesn't work
-and someone (e.g., you, in the future) needs to figure out why,
-being able to pass `--verbose` to get additional log output
-can make the difference between minutes and hours of debugging.
-The [clap-verbosity-flag] crate contains a quick way
-to add a `--verbose` to a project using `clap`.
+**팁:**
+경험적으로, 가볍게 쓸만한 CLI 프로그램도 향후 수년간 사용되곤 합니다.
+(특히 임시 방편으로 프로그램을 만든 경우.)
+만약 애플리케이션이 동작하지 않아서 다른 사용자(가령 미래의 여러분)가 그 원인을 찾아야 할 때,
+`--verbose`를 전달해 추가적인 로그 출력을 확인할 수 있다면 디버깅에 수 분내지는 수 시간을 절약할 수 있습니다.
+[clap-verbosity-flag] 크레이트는 `clap`을 사용해 프로젝트에 쉽게 `--verbose`를 추가할 수 있도록 해줍니다.

 [clap-verbosity-flag]: https://crates.io/crates/clap-verbosity-flag

diff --git a/src/tutorial/packaging.md b/src/tutorial/packaging.md
index 28128db..ac811ec 100644
--- a/src/tutorial/packaging.md
+++ b/src/tutorial/packaging.md
@@ -1,44 +1,40 @@
-# Packaging and distributing a Rust tool
-
-If you feel confident that your program is ready for other people to use,
-it is time to package and release it!
-
-There are a few approaches,
-and we'll look at three of them
-from "quickest to set up" to "most convenient for users".
-
-## Quickest: `cargo publish`
-
-The easiest way to publish your app is with cargo.
-Do you remember how we added external dependencies to our project?
-Cargo downloaded them from its default "crate registry", [crates.io].
-With `cargo publish`,
-you too can publish crates to [crates.io].
-And this works for all crates,
-including those with binary targets.
-
-Publishing a crate to [crates.io] is pretty straightforward:
-If you haven't already, create an account on [crates.io].
-Currently, this is done via authorizing you on GitHub,
-so you'll need to have a GitHub account
-(and be logged in there).
-Next, you log in using cargo on your local machine.
-For that, go to your
-[crates.io account page],
-create a new token,
-and then run `cargo login <your-new-token>`.
-You only need to do this once per computer.
-You can learn more about this
-in cargo's [publishing guide].
-
-Now that cargo as well as crates.io know you,
-you are ready to publish crates.
-Before you hastily go ahead and publish a new crate (version),
-it's a good idea to open your `Cargo.toml` once more
-and make sure you added the necessary metadata.
-You can find all the possible fields you can set
-in the documentation for [cargo's manifest format].
-Here's a quick overview of some common entries:
+# 러스트 도구 패키징, 배포하기
+
+다른 사람들에게 여러분의 프로그램을 공개할 수 있을 정도로 자신감이 생겼다면,
+이제 프로그램을 패키징하고 릴리즈할 때입니다!
+
+여기에는 몇 가지 방법이 있는데,
+"가장 빠르게 배포하는 방법"부터 "사용자에게 가장 편리한 방법"까지
+크게 세 가지의 방법을 살펴볼 것입니다.
+
+## 가장 빠른 방법: `cargo publish`
+
+앱을 공개하는 가장 쉬운 방법은 cargo를 이용하는 것입니다.
+프로젝트에 외부 디펜던시를 어떻게 추가하는지 기억하시나요?
+cargo는 기본 "크레이트 레지스트리"인 [crates.io]에서 해당하는
+디펜던시를 다운로드합니다.
+`cargo publish`를 이용하면 바이너리 타겟을 비롯한
+여러분의 크레이트를 [crates.io]에 공개할 수 있습니다.
+
+[crates.io]에 크레이트를 공개하는 것은 상당히 직관적입니다.
+우선 [crates.io]에 계정이 없다면 가입하세요.
+현재로써는 GitHub을 통해 인증을 해야 하므로,
+GitHub 계정도 필요합니다.
+그 다음엔, 로컬 머신에서 cargo를 이용해 로그인합니다.
+이를 위해, [crates.io 계정 페이지]에 들어가서
+새 토큰을 생성하고 `cargo login <새-토큰>`을 실행하세요.
+이 과정은 컴퓨터당 한 번만 하면 됩니다.
+cargo의 [퍼블리싱 가이드]에서 더 자세한
+내용을 배울 수 있습니다.
+
+이제 cargo는 crates.io에 따라 여러분을 알게 되었고,
+크레이트를 공개할 준비가 끝났습니다.
+새로운 크레이트(또는 새 버전)를 공개하기에 앞서,
+`Cargo.toml`을 열어 필수적인 메타데이터를 추가했는지
+한 번 더 봑인해 보는 것이 좋습니다.
+`Cargo.toml`에 설정할 수 있는 모든 필드는
+[cargo 매니페스트 형식]에서 찾아볼 수 있습니다.
+아래는 빠르게 참고할만한 일반적인 예시입니다:

 ```toml
 [package]
@@ -56,284 +52,261 @@ categories = ["command-line-utilities"]

 <aside class="note">

-**Note:**
-This example includes the mandatory license field
-with a common choice for Rust projects:
-The same license that is also used for the compiler itself.
-It also refers to a `README.md` file.
-It should include a quick description of what your project is about,
-and will be included not only on the crates.io page of your crate,
-but also what GitHub shows by default on repository pages.
+**참고:**
+이 예시에서는 러스트 프로젝트에 주로 채택하는 라이센스로
+필수 필드를 채웠습니다:
+러스트 컴파일러도 같은 라이센스를 사용하고 있습니다.
+또한 여기에서는 `README.md` 파일도 명시하고 있습니다.
+`README.md` 파일은 프로젝트에 대한 설명을 포함해야 하며,
+이 설명은 crates.io 페이지 뿐만 아니라
+GitHub의 저장소 페이지에도 노출됩니다.

 </aside>

 [crates.io]: https://crates.io/
-[crates.io account page]: https://crates.io/me
-[publishing guide]: https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html
-[cargo's manifest format]: https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html
-
-### How to install a binary from crates.io
-
-We've seen how to publish a crate to crates.io,
-and you might be wondering how to install it.
-In contrast to libraries,
-which cargo will download and compile for you
-when you run `cargo build` (or a similar command),
-you'll need to tell it to explicitly install binaries.
-
-This is done using
-`cargo install <crate-name>`.
-It will by default download the crate,
-compile all the binary targets it contains
-(in "release" mode, so it might take a while)
-and copy them into the `~/.cargo/bin/` directory.
-(Make sure that your shell knows to look there for binaries!)
-
-It's also possible to
-install crates from git repositories,
-only install specific binaries of a crate,
-and specify an alternative directory to install them to.
-Have a look at `cargo install --help` for details.
-
-### When to use it
-
-`cargo install` is a simple way to install a binary crate.
-It's very convenient for Rust developers to use,
-but has some significant downsides:
-Since it will always compile your source from scratch,
-users of your tool will need to have
-Rust, cargo, and all other system dependencies your project requires
-to be installed on their machine.
-Compiling large Rust codebases can also take some time.
-
-It's best to use this for distributing tools
-that are targeted at other Rust developers.
-For example:
-A lot of cargo subcommands
-like `cargo-tree` or `cargo-outdated`
-can be installed with it.
-
-## Distributing binaries
-
-Rust is a language that compiles to native code
-and by default statically links all dependencies.
-When you run `cargo build`
-on your project that contains a binary called `grrs`,
-you'll end up with a binary file called `grrs`.
-Try it out:
-Using `cargo build`, it'll be `target/debug/grrs`,
-and when you run `cargo build --release`, it'll be `target/release/grrs`.
-Unless you use crates
-that explicitly need external libraries to be installed on the target system
-(like using the system's version of OpenSSL),
-this binary will only depend on common system libraries.
-That means,
-you take that one file,
-send it to people running the same operating system as you,
-and they'll be able to run it.
-
-This is already very powerful!
-It works around two of the downsides we just saw for `cargo install`:
-There is no need to have Rust installed on the user's machine,
-and instead of it taking a minute to compile,
-they can instantly run the binary.
-
-So, as we've seen,
-`cargo build` _already_ builds binaries for us.
-The only issue is,
-those are not guaranteed to work on all platforms.
-If you run `cargo build` on your Windows machine,
-you won't get a binary that works on a Mac by default.
-Is there a way to generate these binaries
-for all the interesting platforms
-automatically?
-
-### Building binary releases on CI
-
-If your tool is open sourced
-and hosted on GitHub,
-it's quite easy to set up a free CI (continuous integration) service
-like [Travis CI].
-(There are other services that also work on other platforms, but Travis is very popular.)
-This basically runs setup commands
-in a virtual machine
-each time you push changes to your repository.
-What those commands are,
-and the types of machines they run on,
-is configurable.
-For example:
-A good idea is to run `cargo test`
-on a machine with Rust and some common build tools installed.
-If this fails,
-you know there are issues in the most recent changes.
+[crates.io 계정 페이지]: https://crates.io/me
+[퍼블리싱 가이드]: https://doc.rust-lang.org/1.39.0/cargo/reference/publishing.html
+[cargo 매니페스트 형식]: https://doc.rust-lang.org/1.39.0/cargo/reference/manifest.html
+
+### crates.io에서 바이너리를 설치하는 방법
+
+앞서 crates.io에 크레이트를 공개하는 방법을 살펴봤는데,
+아마 어떻게 설치할 수 있는지도 궁금할 것입니다.
+`cargo build` (또는 이와 비슷한 명령)를 실행하면
+cargo가 알아서 라이브러리를 다운로드하고 컴파일해줬지만,
+바이너리를 설치할 때는 명시적으로
+어떤 바이너리를 설치할지 명시해야 합니다.
+
+바이너리 설치는 `cargo install <크레이트-이름>`으로 할 수 있습니다.
+이 명령은 기본적으로 크레이트를 다운로드하고,
+크레이트에 포함된 모든 바이너리 타켓을 컴파일한 다음
+("릴리즈" 모드에서 시간이 조금 걸릴 수 있습니다.)
+그 결과물을 `~/.cargo/bin/` 디렉토리로 복사합니다.
+(쉘이 설치된 바이너리를 찾을 수 있는지 확인하세요!)
+
+git 저장소를 통해 크레이트를
+설치할 수도 있습니다.
+또한 크레이트의 특정 바이너리만을 설치하거나,
+바이너리를 설치할 대체 디렉토리도 지정할 수 있습니다.
+자세한 정보는 `cargo install --help`를 참고하세요.
+
+### 사용할 때
+
+`cargo install`은 바이너리 크레이트를 설치하는 쉬운 방법입니다.
+이는 러스트 개발자가 사용하기에 매우 편리한 방법이지만,
+심각한 단점도 있습니다:
+이렇게 크레이트를 설치하면 항상 소스를
+밑바닥부터 컴파일하게 되며,
+사용자는 자신의 기기에 바이너리를 설치하기 위해
+러스트와 cargo, 그리고 여러분의 프로젝트가 요구하는
+모든 시스템 디펜던시를 필요로 하게 됩니다.
+거대한 러스트 코드베이스를 컴파일하면 시간이 오래 걸릴 수도 있습니다.
+
+다른 러스트 개발자를 대상으로 도구를 배포할 때는
+이렇게 하는 것이 가장 좋습니다.
+예를 들어:
+`cargo-tree` 또는 `cargo-outdated`와 같은
+많은 cargo 서브커맨드를 함께 설치할 수 있습니다.
+
+## 바이너리 배포하기
+
+러스트는 네이티브 코드로 컴파일되고,
+기본적으로 모든 디펜던시를 정적으로 링크하는 언어입니다.
+`grrs`라는 바이너리를 가진 프로젝트에서
+`cargo build`를 실행하면,
+최종적으로 `grrs`라는 바이너리를 얻게 됩니다.
+시도해보세요:
+`cargo build`로 빌드하면 바이너리 파일이 `target/debug/grrs`에 만들어지고,
+`cargo build --release`로 빌드하면 `target/release/grrs`에 만들어집니다.
+대상 시스템에 특정 외부 라이브러리 설치를 필요로하는 크레이트
+(시스템 버전의 OpenSSL을 사용하는 등)를 사용하는 것이 아닌 이상,
+이렇게 만들어진 바이너리는 공통 시스템 라이브러리에만 의존합니다.
+즉, 파일 하나를 같은 운영 체제를 사용하는 다른 사람들에게 보내면
+파일을 받은 사람들이 바이너리를 실행할 수 있습니다.
+
+이것만으로도 이미 강력합니다!
+방금 본 `cargo install`의 두 가지 단점을 뛰어넘을 수 있습니다:
+사용자의 기기에 러스트를 설치할 필요도 없고,
+컴파일하기 위해 오랜 시간을 기다릴 필요도 없습니다.
+사용자는 바로 바이너리를 실행할 수 있습니다.
+
+앞서 봤듯이, `cargo build`는 우리를 위한 바이너리를 빌드합니다.
+유일한 문제는 그 바이너리를 모든 플랫폼에서 작동한다고 보장할 수 없다는 것입니다.
+여러분의 윈도우즈 머신에서 `cargo build`를 실행한다면
+기본적으로 맥에서 작동하는 바이너리를 없습니다.
+모든 플랫폼에서 작동하는 바이너리를 자동으로 생성할
+방법이 있을까요?
+
+### CI로 바이너리 릴리즈 빌드하기
+
+여러분의 도구가 오픈소스이고
+GitHub에서 호스트되고 있다면,
+매우 쉽게 [Travis CI]와 같은
+무료 CI(continuous integration) 서비스를 설정할 수 있습니다.
+(다른 플랫폼에서 작동하는 다른 서비스들도 있지만, Travis가 유명합니다.)
+CI는 기본적으로 저장소에 변경사항을 푸시할 때마다
+가상 머신에서 명령을 실행합니다.
+CI에서 어떤 명령을 사용할지,
+어떤 종류의 머신을 사용할지
+설정할 수 있습니다.
+예를 들어:
+러스트와 몇몇 일반적인 빌드 도구가 설치된 머신에서
+`cargo test`를 실행하는 것이 좋습니다.
+만약 테스트가 실패한다면,
+최신 변경사항에 문제가 있다는 사실을 알 수 있습니다.

 [Travis CI]: https://travis-ci.com/

-We can also use this
-to build binaries and upload them to GitHub!
-Indeed, if we run
-`cargo build --release`
-and upload the binary somewhere,
-we should be all set, right?
-Not quite.
-We still need to make sure the binaries we build
-are compatible with as many systems as possible.
-For example,
-on Linux we can compile not for the current system,
-but instead for the `x86_64-unknown-linux-musl` target,
-to not depend on default system libraries.
-On macOS, we can set `MACOSX_DEPLOYMENT_TARGET` to `10.7`
-to only depend on system features present in versions 10.7 and older.
-
-You can see one example of building binaries using this approach
-[here][wasm-pack-travis] for Linux and macOS
-and [here][wasm-pack-appveyor] for Windows (using AppVeyor).
+CI를 통해 바이너리를 빌드하고
+GitHub에 업로드할 수도 있습니다!
+실제로 `cargo build --release`를 실행하고
+어딘가에 바이너리를 업로드하면
+모든 준비가 끝납니다. 그렇죠?
+사실 그렇지 않습니다.
+우리가 빌드한 바이너리가
+최대한 많은 시스템과 호환되는지
+확인해야 합니다.
+예를 들어,
+리눅스에서는 현재 시스템이 아닌
+`x86_64-unknown-linux-musl`을 대상으로 컴파일을 하여
+기본 시스템 라이브러리에 의존하지 않도록 할 수 있습니다.
+macOS에서는 `MACOSX_DEPLOYMENT_TARGET`을 `10.7`로 설정하면
+10.7 버전 이상의 시스템에만 있는 기능에만 의존하도록 할 수 있습니다.
+
+이러한 바이너리 빌드 방법의 예시를 Linux, macOS를 대상으로 한
+[여기][wasm-pack-travis]과 윈도우즈를 대상으로 한
+[여기][wasm-pack-appveyor]에서 볼 수 있습니다.

 [wasm-pack-travis]: https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91
 [wasm-pack-appveyor]: https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml

-Another way is to use pre-built (Docker) images
-that contain all the tools we need
-to build binaries.
-This allows us to easily target more exotic platforms, too.
-The [trust] project contains
-scripts that you can include in your project
-as well as instructions on how to set this up.
-It also includes support for Windows using AppVeyor.
-
-If you'd rather set this up locally
-and generate the release files on your own machine,
-still have a look at trust.
-It uses [cross] internally,
-which works similar to cargo
-but forwards commands to a cargo process inside a Docker container.
-The definitions of the images are also available in
-[cross' repository][cross].
+또 다른 방법은 바이너리를 빌드할 때 필요한
+모든 도구를 갖추고 있는 pre-built (도커) 이미지를 사용하는 것입니다.
+이를 통해 보다 다양한 플랫폼을 쉽게 공략할 수 있습니다.
+[trust] 프로젝트에는
+여러분의 프로젝트에 사용할 수 있는 스크립트와
+이를 설정하는 방법에 대한 설명이 있으며,
+AppVeyor를 통해 윈도우즈도 지원합니다.
+
+만약 로컬에서 모든 설정을 하고
+릴리즈 파일을 자신의 컴퓨터에 생성하고 싶은 경우에도
+[trust]를 확인해보세요.
+[trust]는 내부적으로 [cross]를 사용하는데,
+이는 cargo와 비슷하게 동작하지만
+도커 컨테이너 내부의 cargo 프로세스로 명령을
+전달합니다.
+여기에 사용하는 이미지 정의는
+[cross]에서도 사용할 수 있씁니다.

 [trust]: https://github.com/japaric/trust
 [cross]: https://github.com/rust-embedded/cross

-### How to install these binaries
+### 바이너리 설치하는 방법

-You point your users to your release page
-that might look something [like this one][wasm-pack-release],
-and they can download the artifacts we've just created.
-The release artifacts we've just generated are nothing special:
-At the end, they are just archive files that contain our binaries!
-This means that users of your tool
-can download them with their browser,
-extract them (often happens automatically),
-and copy the binaries to a place they like.
+사용자에게 [wasm-pack-release]와 같은 릴리즈 페이지를 제공하면
+사용자는 우리가 생성한 아티팩트를 다운로드할 수 있습니다.
+우리가 생성한 릴리즈 아티팩트는 특별한 것이 아닙니다:
+결국 바이너리를 포함한 아카이브 파일일 뿐입니다!
+즉, 여러분이 만든 도구의 사용자들은
+자신의 브라우저를 이용해 파일을 다운로드하고
+파일의 압축을 푼 다음(보통 자동으로 됩니다.),
+원하는 위치에 바이너리를 복사해 사용하게 됩니다.

 [wasm-pack-release]: https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1

-This does require some experience with manually "installing" programs,
-so you want to add a section to your README file
-on how to install this program.
+이러한 과정은 수동으로 프로그램을 "설치"하는 경험을 수반하기 때문에
+README 파일에 프로그램을 설치하는 방법에 대해
+설명하는 섹션을 추가할 필요가 있습니다.

 <aside class="note">

-**Note:**
-If you used [trust] to build your binaries and added them to GitHub releases,
-you can also tell people to run
-`curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name`
-if you think that makes it easier.
+**참고:**
+만약 [trust]를 이용해 바이너리를 빌드하고, 이를 GitHub 릴리즈에 추가했다면 사람들에게
+`curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name`를
+실행하라고 안내할 수도 있습니다.

 </aside>

-### When to use it
-
-Having binary releases is a good idea in general,
-there's hardly any downside to it.
-It does not solve the problem of users having to manually
-install and update
-your tools,
-but they can quickly get the latest releases version
-without the need to install Rust.
-
-### What to package in addition to your binaries
-
-Right now,
-when a user downloads our release builds,
-they will get a `.tar.gz` file
-that only contains binary files.
-So, in our example project,
-they will just get a single `grrs` file they can run.
-But there are some more files we already have in our repository
-that they might want to have.
-The README file that tells them how to use this tool,
-and the license file(s),
-for example.
-Since we already have them,
-they are easy to add.
-
-There are some more interesting files
-that make sense especially for command-line tools,
-though:
-How about we also ship a man page in addition to that README file,
-and config files that add completions of the possible flags to your shell?
-You can write these by hand,
-but _clap_, the argument parsing library we use
-(which clap builds upon)
-has a way to generate all these files for us.
-See [this in-depth chapter][clap-man-pages]
-for more details.
-
+### 사용할 때
+
+바이너리 릴리즈는 일반적으로 좋은 선택이며,
+단점이 거의 없습니다.
+사용자가 수동으로 도구를 설치하고
+업데이트해야 한다는 문제를 해결하지는 못하지만,
+러스트를 설치하지 않고 빠르게 최신 릴리즈 버전을
+설치할 수 있습니다.
+
+### 바이너리에 추가로 패키징할 것
+
+이제 사용자가 릴리즈 빌드를 다운로드하면
+바이너리 파일만이 포함된 `.tar.gz` 파일을 얻게 됩니다.
+따라서 우리의 예시 프로젝트의 경우
+사용자는 하나의 실행 가능한 `grrs` 파일을 얻습니다.
+그런데 우리의 저장소에는 더 많은 파일이 있고,
+사용자가 추가적인 파일을 받길 원할 수도 있습니다.
+예를 들어 도구를 어떻게 사용해야 하는지 설명하는 README 파일이나
+라이센스 파일을 제공할 수 있습니다.
+프로젝트에 이미 파일이 있으므로,
+쉽게 추가할 수 있습니다.
+
+특히 커맨드라인 도구에 적합한 몇몇 흥미로운
+파일들이 있습니다:
+README 파일 외에 man 페이지를 추가로 제공하거나,
+쉘에서 사용할 수 있는 플래그에 대한 자동완성 설정 파일을
+제공하는 건 어떨까요?
+이를 직접 손으로 작성할 수도 있겠지만,
+우리가 사용하는 인자 파싱 라이브러리 clap은
+파일을 자동으로 생성해 줍니다.
+더 자세한 내용은 이 책의 [더 깊은 주제][clap-man-pages]에서
+찾아보세요.

 [clap-man-pages]: ../in-depth/docs.html

-
-## Getting your app into package repositories
-
-Both approaches we've seen so far
-are not how you typically install software on your machine.
-Especially command-line tools
-you install using global package managers
-on most operating systems.
-The advantages for users are quite obvious:
-There is no need to think about how to install your program,
-if it can be installed the same way as they install the other tools.
-These package managers also allow users to update their programs
-when a new version is available.
-
-Sadly, supporting different systems means
-you'll have to look at how these different systems work.
-For some,
-it might be as easy as adding a file to your repository
-(e.g. adding a Formula file like [this][rg-formula] for macOS's `brew`),
-but for others you'll often need to send in patches yourself
-and add your tool to their repositories.
-There are helpful tools like
-[cargo-bundle](https://crates.io/crates/cargo-bundle),
-[cargo-deb](https://crates.io/crates/cargo-deb), and
-[cargo-aur](https://crates.io/crates/cargo-aur),
-but describing how they work
-and how to correctly package your tool
-for those different systems is beyond the scope of this chapter.
+## 패키지 저장소를 통해 애플리케이션 설치하기
+
+앞서 살펴본 두 방법은 모두
+일반적으로 기기에 소프트웨어를 설치하는 방식은 아닙니다.
+특히 커맨드라인 툴은 대부분의 운영체제에서 글로벌 패키지
+매니저를 통해 설치합니다.
+이렇게 하면 사용자는 다른 프로그램을 설치하는 것과 같은 방식으로
+여러분의 프로그램을 설치할 수 있으므로,
+프로그램을 설치하는 방법에 대해 신경쓸 필요가 없습니다.
+이러한 패키지 매니저는 프로그램의 새 버전을 사용할 수 있게 됐을 때
+사용자가 프로그램을 업데이트할 수 있도록 해줍니다.
+
+슬프게도, 서로 다른 시스템을 지원한다는 것은
+각 시스템이 어떻게 동작하는지 살펴봐야 함을 의미합니다.
+어떤 경우에는 저장소에 파일을 추가하는 것만큼 쉬울 수도 있습니다.
+(가령, macOS의 `brew`를 사용하기 위해 [이것][rg-formula]과 같은 포뮬러(Formula) 파일을 추가할 수 있습니다.)
+하지만 그 외의 경우에는 대체로 직접 패치를 전송해 해당 패키지 매니저의 저장소에
+여러분의 프로그램을 추가해야 합니다.
+이때 [cargo-bundle](https://crates.io/crates/cargo-bundle),
+[cargo-deb](https://crates.io/crates/cargo-deb),
+[cargo-aur](https://crates.io/crates/cargo-aur)과 같은 유용한 도구를 사용할 수 있습니다.
+이 챕터에서는 다양한 시스템에서 이들이 어떻게 동작하는지,
+어떻게 여러분의 프로그램을 올바르게 패키징할 수 있는지
+설명하지는 않습니다.

 [rg-formula]: https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb

-Instead,
-let's have a look at a tool that is written in Rust
-and that is available in many different package managers.
+대신 다양한 패키지 매니저에서 사용할 수 있는
+러스트 도구를 살펴보겠습니다.

-### An example: ripgrep
+### 예시: ripgrep

-[ripgrep] is an alternative to `grep`/`ack`/`ag` and is written in Rust.
-It's quite successful and is packaged for many operating systems:
-Just look at [the "Installation" section][rg-install] of its README!
+[ripgrep]은 러스트로 작성된 `grep`/`ack`/`ag` 대체품입니다.
+[ripgrep]은 매우 성공적인 프로젝트이며, 많은 운영체제에 대해 패키징되어 있습니다:
+프로젝트의 README에서 ["Installation" 섹션][rg-install]을 살펴보세요!

-Note that it lists a few different options how you can install it:
-It starts with a link to the GitHub releases
-which contain the binaries so you can download them directly;
-then it lists how to install it using a bunch of different package managers;
-finally, you can also install it using `cargo install`.
+설치 방법에는 몇 가지 선택지가 있습니다:
+먼저 GitHub 릴리즈 링크를 통해 바이너리를 직접 다운로드하는 방법이 있습니다.
+또는 다양한 패키지 매니저를 통해 설치하는 방법도 있습니다.
+마지막으로 `cargo install`을 통해 설치하는 방법이 있습니다.

-This seems like a very good idea:
-Don't pick and choose one of the approaches presented here,
-but start with `cargo install`,
-add binary releases,
-and finally start distributing your tool using system package managers.
+여기에 나열된 방법 중 하나를 따르지 않고
+`cargo install`로 바이너리 릴리즈를 추가하는 것으로 시작해
+최종적으로 여러분의 도구를 시스템 패키지 매니저를 통해
+배포해보는 것도 것도 좋은 생각인 것 같습니다.

 [ripgrep]: https://github.com/BurntSushi/ripgrep
 [rg-install]: https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation
diff --git a/src/tutorial/setup.md b/src/tutorial/setup.md
index dca729c..fc9c42e 100644
--- a/src/tutorial/setup.md
+++ b/src/tutorial/setup.md
@@ -1,27 +1,22 @@
-# Project setup
+# 프로젝트 준비

-If you haven’t already,
-[install Rust] on your computer
-(it should only take a few minutes).
-After that, open a terminal and navigate to the directory
-you want to put your application code into.
+아직 컴퓨터에 [러스트를 설치]하지 않았다면 설치하세요. (몇 분 정도만 걸립니다)
+이어서, 터미널을 열고 애플리케이션 코드를 위치할 디렉토리로 이동하세요.

-[install Rust]: https://www.rust-lang.org/tools/install
+[러스트를 설치]: https://www.rust-lang.org/tools/install

-Start by running
-`cargo new grrs`
-in the directory you store your programming projects in.
-If you look at the newly created `grrs` directory,
-you’ll find a typical setup for a Rust project:
+프로그래밍 프로젝트를 보관할 디렉토리에서
+`cargo new grrs`를 실행해 프로젝트를 시작하세요.
+`grrs` 디렉토리가 새롭게 만들어졌다면,
+일반적인 러스트 프로젝트 파일을 확인할 수 있을 것입니다:

-- A `Cargo.toml` file that contains metadata for our project,
-  incl. a list of dependencies/external libraries we use.
-- A `src/main.rs` file that is the entry point for our (main) binary.
+- `Cargo.toml`: 프로젝트의 메타데이터와 프로젝트에서 사용할 디펜던시/외부 라이브러리 목록을 담고있는 파일.
+- `src/main.rs`: 프로그램 바이너리(main)의 엔트리포인트 파일.

-If you can execute `cargo run` in the `grrs` directory
-and get a "Hello World", you’re all set up.
+`grrs` 디렉토리에서 `cargo run`을 실행했을 때
+"Hello World"가 출력된다면 모든 준비를 마친 것입니다.

-## What it might look like
+## 이렇게 보여야 합니다

 ```console
 $ cargo new grrs
diff --git a/src/tutorial/testing.md b/src/tutorial/testing.md
index 646768d..21ffb43 100644
--- a/src/tutorial/testing.md
+++ b/src/tutorial/testing.md
@@ -1,49 +1,47 @@
-# Testing
-
-Over decades of software development,
-people have discovered one truth:
-Untested software rarely works.
-(Many people would go as far as saying:
-"Most tested software doesn't work either."
-But we are all optimists here, right?)
-So, to ensure that your program does what you expect it to do,
-it is wise to test it.
-
-One easy way to do that is
-to write a `README` file
-that describes what your program should do.
-And when you feel ready to make a new release,
-go through the `README` and ensure that
-the behavior is still as expected.
-You can make this a more rigorous exercise
-by also writing down how your program should react to erroneous inputs.
-
-Here's another fancy idea:
-Write that `README` before you write the code.
+# 테스트
+
+지난 수십 년간 소프트웨어 개발 분야에서
+사람들은 한 가지 진실을 발견했습니다:
+테스트하지 않은 소프트웨어는 대부분 동작하지 않는다.
+(많은 사람들이 더 나아가서 "테스트한 소프트웨어도 대체로 동작하지 않는다"고 말합니다.
+그래도 여기서 우리는 모두 낙관론자입니다. 그렇죠?)
+따라서, 프로그램이 예상대로 동작하는지 확인하려면
+테스트를 하는 것이 현명합니다.
+
+한 가지 쉬운 방법은 `README` 파일에
+프로그램이 어떻게 동작해야 하는
+작성하는 것입니다.
+그러면 새로운 버전을 출시할 준비가 됐을 때
+`README` 파일을 읽어보고 프로그램이
+예상대로 동작하는지 확인할 수 있습니다.
+이때 프로그램이 잘못된 입력에 대해 어떻게 동작해야 하는지도
+적어두면 더 엄격히 검증할 수 있습니다.
+
+또 다른 그럴듯한 아이디어가 있습니다:
+바로 코드를 작성하기 전에 `README`를 작성하는 것입니다.

 <aside>

-**Note:**
-Have a look at
-[test-driven development] (TDD)
-if you haven't heard of it.
+**참고:**
+[테스트 주도 개발](TDD)를 처음 들어본다면
+확인해보세요.

-[test-driven development]: https://en.wikipedia.org/wiki/Test-driven_development
+[테스트 주도 개발]: https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C


 </aside>

-## Automated testing
+## 테스트 자동화

-Now, this is all fine and dandy,
-but doing all of this manually?
-That can take a lot of time.
-At the same time,
-many people have come to enjoy telling computers to do things for them.
-Let's talk about how to automate these tests.
+모든 것이 멋져 보이지만,
+이 모든 것을 수동으로 해야 할까요?
+수동으로 하면 시간이 오래 걸릴 수 있습니다.
+또한 많은 사람들이 컴퓨터에게 자신을 위해
+뭔가를 수행하도록 지시하는 것을 좋아합니다.
+이제 테스트를 자동화하는 방법에 대해 살펴보겠습니다.

-Rust has a built-in test framework,
-so let's start by writing a first test:
+러스트는 빌트인 테스트 프레임워크를 갖추고 있습니다.
+첫 테스트를 작성해봅시다:

 ```rust,ignore
 # fn answer() -> i32 {
@@ -56,20 +54,19 @@ fn check_answer_validity() {
 }
 ```

-You can put this snippet of code in pretty much any file
-and `cargo test` will find
-and run it.
-The key here is the `#[test]` attribute.
-It allows the build system to discover such functions
-and run them as tests,
-verifying that they don't panic.
+위의 코드 스니펫을 아무 파일에나 작성하고
+`cargo test`를 실행하면 테스트가 시작됩니다.
+여기서 핵심은 `#[test]` 속성입니다.
+이 속성은 빌드 시스템이 위와 같은 함수를 찾고
+테스트로 실행해 패닉이 일어나지 않음을
+검증할 수 있도록 해줍니다.

 <aside class="exercise">

-**Exercise for the reader:**
-Make this test work.
+**연습:**
+이 테스트가 동작하도록 만들어 보세요.

-You should end up with output like the following:
+아래와 같은 출력이 나와야 합니다:

 ```text
 running 1 test
@@ -80,35 +77,33 @@ test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

 </aside>

-Now that we've seen *how* we can write tests,
-we still need to figure out *what* to test.
-As you've seen it's fairly easy to write assertions
-for functions.
-But a CLI application is often more than one function!
-Worse, it often deals with user input,
-reads files,
-and writes output.
-
-## Making your code testable
-
-There are two complementary approaches to testing functionality:
-Testing the small units that you build your complete application from,
-these are called "unit tests".
-There is also testing the final application "from the outside"
-called "black box tests" or "integration tests".
-Let's begin with the first one.
-
-To figure out what we should test,
-let's see what our program features are.
-Mainly, `grrs` is supposed to print out the lines that match a given pattern.
-So, let's write unit tests for _exactly this_:
-We want to ensure that our most important piece of logic works,
-and we want to do it in a way that is not dependent
-on any of the setup code we have around it
-(that deals with CLI arguments, for example).
-
-Going back to our [first implementation](impl-draft.md) of `grrs`,
-we added this block of code to the `main` function:
+우리는 테스트를 *어떻게* 작성하는지 살펴봤고,
+이제 *무엇을* 테스트할지 알아내야 합니다.
+앞서 봤듯이 함수를 어서션(assertion)하는 테스트를
+작성하기는 매우 쉽습니다.
+하지만 CLI 애플리케이션에는 보통 여러 함수가 있습니다.
+심지어 그 함수들이 사용자의 입력을 받고, 파일을 읽으며,
+출력을 냅니다.
+
+## 코드를 테스트 가능하게 만들기
+
+기능 테스트에는 두 가지의 보완적 접근법이 있습니다:
+하나는 전체 애플리케이션을 빌드할 때 사용되는
+작은 단위를 테스트하는 "유닛 테스트"입니다.
+다른 하나는 "외부에서" 최종 애플리케이션을 테스트하는
+"블랙 박스 테스트" 또는 "통합 테스트"입니다.
+유닛 테스트부터 시작해 봅시다.
+
+무엇을 테스트할지 알아내기 위해서는
+프로그램의 기능을 살펴봐야 합니다.
+`grrs`의 주요 기능은 주어진 패턴에 일치하는 라인을 출력하는 것입니다.
+따라서 _정확히 이 기능_ 에 대한 테스트를 작성해 봅시다.
+우리는 로직의 가장 중요한 부분이 동작하는지 확인해야 하고,
+이를 둘러싼 어떠한 설정 코드(예를 들어 CLI 인자를 다루는 코드)에도
+의존하지 않는 방식으로 테스트를 해야 합니다.
+
+`grrs`의 [첫 구현](impl-draft.md)에서
+우리는 `main` 함수에 아래 코드 블록을 추가했습니다:

 ```rust,ignore
 // ...
@@ -119,9 +114,9 @@ for line in content.lines() {
 }
 ```

-Sadly, this is not very easy to test.
-First of all, it's in the main function, so we can't easily call it.
-This is easily fixed by moving this piece of code into a function:
+슬프게도, 이 코드는 테스트하기 어렵습니다.
+일단 코드가 메인 함수 안에 있기 때문에 호출하는 것부터 쉽지 않습니다.
+이 문제는 별도 함수로 코드 조각을 분리함으로써 쉽게 개선할 수 있습니다:

 ```rust,no_run
 fn find_matches(content: &str, pattern: &str) {
@@ -133,8 +128,7 @@ fn find_matches(content: &str, pattern: &str) {
 }
 ```

-Now we can call this function in our test,
-and see what its output is:
+이제 테스트에서 함수를 호출할 수 있습니다:

 ```rust,ignore
 #[test]
@@ -143,103 +137,90 @@ fn find_a_match() {
     assert_eq!( // uhhhh
 ```

-Or… can we?
-Right now, `find_matches` prints directly to `stdout`, i.e., the terminal.
-We can't easily capture this in a test!
-This is a problem that often comes up
-when writing tests after the implementation:
-We have written a function that is firmly integrated
-in the context it is used in.
+이렇게 할 수 있을까요?
+여기서 `find_matches`는 `stdout`, 즉, 터미널에 직접 결과를 출력합니다.
+테스트에서는 그 출력을 쉽게 포착할 수가 없습니다.
+구현한 뒤에 테스트를 작성하면 함수가 사용되는 맥락 안에 함수를 완전히
+통합하게 되기 때문에 이런 문제가 자주 일어납니다.

 <aside class="note">

-**Note:**
-This is totally fine when writing small CLI applications.
-There's no need to make everything testable!
-It is important to think about
-which parts of your code you might want to write unit tests for, however.
-While we'll see that it's easy to change this function to be testable,
-this is not always the case.
+**참고:**
+작은 CLI 애플리케이션을 작성할 때는 그래도 전혀 문제가 없습니다.
+모든 것을 테스트 가능하게 만들 필요는 없죠!
+하지만 코드의 어느 부분에 대해 유닛 테스트를 작성할지
+고민하는 것은 중요합니다.
+아래에서 이 함수를 쉽게 테스트 가능한 형태로 개선하겠지만,
+항상 간단하지는 않습니다.

 </aside>

-Alright, how can we make this testable?
-We'll need to capture the output somehow.
-Rust's standard library has some neat abstractions
-for dealing with I/O (input/output)
-and we'll make use of one called [`std::io::Write`].
-This is a [trait][trpl-traits] that abstracts over things we can write to,
-which includes strings but also `stdout`.
+좋습니다, 위 코드를 어떻게 테스트 가능하게 바꿀 수 있을까요?
+어떻게든 출력을 포착할 방법이 필요할 것입니다.
+러스트의 표준 라이브러리는 I/O (input/output)을 다루기 위한
+몇 가지 깔끔한 추상화를 제공하며,
+여기서는 [`std::io::Write`]를 사용해 볼 것입니다.
+[`std::io::Write`]는 문자열 뿐만 아니라, `stdout`까지 비롯한
+쓰기 동작을 추상화해주는 [트레잇]입니다.

-[trpl-traits]: https://doc.rust-lang.org/book/ch10-02-traits.html
+[트레잇]: https://doc.rust-lang.org/book/ch10-02-traits.html
 [`std::io::Write`]: https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html

-If this is the first time you've heard "trait"
-in the context of Rust,
-you are in for a treat.
-Traits are one of the most powerful features of Rust.
-You can think of them like interfaces in Java,
-or type classes in Haskell
-(whatever you are more familiar with).
-They allow you to abstract over behavior
-that can be shared by different types.
-Code that uses traits can
-express ideas in very generic and flexible ways.
-This means it can also get difficult to read, though.
-Don't let that intimidate you:
-Even people who have used Rust for years
-don't always get what generic code does immediately.
-In that case,
-it helps to think of concrete uses.
-For example,
-in our case,
-the behavior that we abstract over is "write to it".
-Examples for the types that implement ("impl") it
-include:
-The terminal's standard output,
-files,
-a buffer in memory,
-or TCP network connections.
-(Scroll down in the [documentation for `std::io::Write`][`std::io::Write`]
-to see a list of "Implementors".)
-
-With that knowledge,
-let's change our function to accept a third parameter.
-It should be of any type that implements `Write`.
-This way,
-we can then supply a simple string
-in our tests
-and make assertions on it.
-Here is how we can write this version of `find_matches`:
+러스트에서 "트레잇"을 처음 들어봤다면,
+아마 마음에 들 것입니다.
+트레잇은 러스트의 강력한 기능 중 하나로,
+자바의 인터페이스나 하스켈의 타입 클래스와 비슷하다고 생각할 수 있습니다.
+(여러분이 더 친숙한 쪽으로 생각해 보세요.)
+이들은 서로 다른 타입이 공유하는 동작을 추상화할 수 있도록 해줍니다.
+트레잇을 사용하는 코드는 개념을
+매우 범용적이면서 유연한 방식으로 표현할 수 있게 됩니다.
+다만 이로 인해 코드를 읽기 어려워지기도 합니다.
+겁먹지는 마세요. 수년간 러스트를 사용해 온 사람들도
+범용적인 코드를 바로 작성하지는 못합니다.
+그럴 때는 구체적인 용도를 생각해 보는 것이 도움 됩니다.
+예를 들어, 우리는 "무언가에 쓴다"라는 동작을
+추상화하고자 합니다.
+[`std::io::Write`]를 구현("impl")하는 타입에는
+터미널의 표준 출력,
+파일,
+메모리 버퍼,
+TCP 네트워크 커넥션 등이 있습니다.
+([`std::io::Write` 문서][`std::io::Write`]에서 스크롤을 내려보면
+"Implementors" 목록을 볼 수 있습니다.)
+
+이러한 배경 지식을 바탕으로,
+우리의 함수가 세 번째 파라미터를 받도록 수정해 봅시다.
+파라미터는 `Write`를 구현하는 타입이어야 합니다.
+이를 통해
+테스트에 간단한 문자열을 전달하고,
+그 값을 어서션할 수 있게 됩니다.
+아래는 수정된 `find_matches` 코드입니다:

 ```rust,ignore
 {{#include testing/src/main.rs:23:29}}
 ```

-The new parameter is `mut writer`,
-i.e., a mutable thing we call "writer".
-Its type is `impl std::io::Write`,
-which you can read as
-"a placeholder for any type that implements the `Write` trait".
-Also note how we
-replaced the `println!(…)`
-we used earlier
-with `writeln!(writer, …)`.
-`println!` works the same as `writeln!`
-but always uses standard output.
+새로운 파라미터는 `mut writer`입니다.
+(즉, "writer"라고 부르는 가변적인 값입니다.)
+이 파라미터의 타입은 `impl std::io::Write`이며,
+이를 "`Write` 트레잇을 구현하는 타입을 위한 플레이스홀더"라고
+읽을 수 있습니다.
+또한 앞서 작성한 `println!(…)`이
+`writeln!(writer, …)`으로 바뀌었습니다.
+`println!`은 `writeln!`과 똑같이 동작하지만
+항상 표준 출력을 사용합니다.

-Now we can test for the output:
+이제 출력을 아래와 같이 테스트할 수 있습니다:

 ```rust,ignore
 {{#include testing/src/main.rs:31:36}}
 ```

-To now use this in our application code,
-we have to change the call to `find_matches` in `main`
-by adding [`&mut std::io::stdout()`][stdout] as the third parameter.
-Here's an example of a main function
-that builds on what we've seen in the previous chapters
-and uses our extracted `find_matches` function:
+이 함수를 애플리케이션 코드에 사용하기 위해서는
+`main`의 `find_matches`에 세 번째 파라미터로
+[`&mut std::io::stdout()`][stdout]를 전달하도록 변경해야 합니다.
+아래는 이전 챕터에서 살펴본 메인 함수가
+앞서 작성한 `find_matches` 함수를 사용하는 예시입니다:

 ```rust,ignore
 {{#include testing/src/main.rs:13:21}}
@@ -249,169 +230,167 @@ and uses our extracted `find_matches` function:

 <aside class="note">

-**Note:**
-Since `stdout` expects bytes (not strings),
-we use `std::io::Write` instead of `std::fmt::Write`.
-As a result,
-we give an empty vector as "writer" in our tests
-(its type will be inferred to `Vec<u8>`),
-in the `assert_eq!` we use a `b"foo"`.
-(The `b` prefix makes this a _byte string literal_
-so its type is going to be `&[u8]` instead of `&str`).
+**참고:**
+`stdout`은 문자열이 아니라 바이트이기 때문에
+`std::fmt::Write` 대신 `std::io::Write`를 사용했습니다.
+결과적으로 테스트에서는 빈 벡터(`Vec<u8>`로 타입 추론)를 "writer"로
+전달했으며, `assert_eq!`에서는 `b"foo"`를 사용했습니다.
+(`b` 접두사는 문자열을 _바이트 문자열 리터럴_ 로 만들어 줍니다.
+따라서 이 타입은 `&str`이 아니라 `&[u8]`이 됩니다.)

 </aside>

 <aside class="note">

-**Note:**
-We could also make this function return a `String`,
-but that would change its behavior.
-Instead of writing to the terminal directly,
-it would then collect everything into a string,
-and dump all the results in one go at the end.
+**참고:**
+`find_matches`가 `String`을 반환하도록 만들 수도 있지만,
+그러려면 동작을 변경해야 합니다.
+터미널에 직접 쓰기를 하는 대신
+모든 것을 하나의 문자열에 모으고,
+한번에 덤프하는 방식으로 할 수 있습니다.

 </aside>

 <aside class="exercise">

-**Exercise for the reader:**
-[`writeln!`] returns an [`io::Result`]
-because writing can fail,
-for example when the buffer is full and cannot be expanded.
-Add error handling to `find_matches`.
+**연습:**
+버퍼가 꽉 차서 확장할 수 없을 때는
+쓰기가 실패할 수 있기 때문에
+[`writeln!`]는 [`io::Result`]를 반환합니다.
+`find_matches`가 에러를 다루도록 수정해보세요.

 [`writeln!`]: https://doc.rust-lang.org/1.39.0/std/macro.writeln.html
 [`io::Result`]: https://doc.rust-lang.org/1.39.0/std/io/type.Result.html

 </aside>

-We've just seen how to make this piece of code easily testable.
-We have
-
-1. identified one of the core pieces of our application,
-2. put it into its own function,
-3. and made it more flexible.
-
-Even though the goal was to make it testable,
-the result we ended up with
-is actually a very idiomatic and reusable piece of Rust code.
-That's awesome!
-
-## Splitting your code into library and binary targets
-
-We can do one more thing here.
-So far we've put everything we wrote into the `src/main.rs` file.
-This means our current project produces a single binary.
-But we can also make our code available as a library, like this:
-
-1. Put the `find_matches` function into a new `src/lib.rs`.
-2. Add a `pub` in front of the `fn` (so it's `pub fn find_matches`)
-   to make it something that users of our library can access.
-3. Remove `find_matches` from `src/main.rs`.
-4. In the `fn main`, prepend the call to `find_matches` with `grrs::`,
-   so it's now `grrs::find_matches(…)`.
-   This means it uses the function from the library we just wrote!
-
-The way Rust deals with projects is quite flexible
-and it's a good idea to think about
-what to put into the library part of your crate early on.
-You can for example think about writing a library
-for your application-specific logic first
-and then use it in your CLI just like any other library.
-Or, if your project has multiple binaries,
-you can put the common functionality into the library part of that crate.
+앞서 하나의 코드 조각을 쉽게 테스트 가능하도록 만드는
+방법에 대해 알아봤습니다. 우리는,
+
+1. 애플리케이션의 핵심 부분 중 하나를 명확히 알게 되었고,
+2. 그 부분을 자체적인 함수로 추출했으며,
+3. 코드를 더욱 유연하게 만들었습니다.
+
+처음에는 그저 코드를 테스트 가능하게 만드는 것이 목표였지만,
+결과적으로 매우 자연스럽고, 재사용 가능한
+러스트 코드를 얻었습니다.
+놀라운 일이죠!
+
+## 코드를 라이브러리와 바이너리 타겟으로 쪼개기
+
+여기서 하나를 더 해볼 수 있습니다.
+지금까지는 모든 코드를 `src/main.rs` 파일에만 작성했습니다.
+이는 현재 프로젝트가 하나의 바이너리로 만들어진다는 것을 의미합니다.
+그런데 코드를 라이브러리로도 만들 수 있습니다. 이렇게요:
+
+1. `find_matches` 함수를 새로 만든 `src/lib.rs` 파일에 넣습니다.
+2. `fn` 앞에 `pub`을 추가합니다. 따라서 `pub fn find_matches`가 됩니다.
+3. `src/main.rs`에서 `find_matches`를 지웁니다.
+4. `fn main`에서 `find_matches`를 호출하는 부분 앞에 `grrs::`를 붙입니다.
+   따라서 `grrs::find_matches(…)`가 됩니다.
+   이것은 우리가 방금 작성한 라이브러리의 함수를 사용한다는 의미입니다!
+
+러스트가 프로젝트를 다루는 방식은 매우 유연하며,
+크레이트의 라이브러리 부분에 어떤 내용을
+작성할지 초기에 생각해보는 것이 좋습니다.
+예를 들어, 애플리케이션에 특정된 로직을 위한
+라이브러리를 먼저 작성한 다음, 그 라이브러리를
+다른 라이브러리처럼 CLI에서 사용할 수 있습니다.
+또는, 프로젝트에 여러 바이너리가 있는 경우
+크레이트의 라이브러리 부분에 공통 기능을 작성할 수 있습니다.

 <aside class="note">

-**Note:**
-Speaking of putting everything into a `src/main.rs`:
-If we continue to do that,
-it'll become difficult to read.
-The [module system] can help you structure and organize your code.
+**참고:**
+`src/main.rs`에 모든 것을 집어 넣으면
+앞으로 코드를 읽기 어려워 집니다.
+[모듈 시스템]이 여러분의 코드를 구조화하고 구성하는 데 도움을 줄 수 있습니다.

-[module system]: https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
+[모듈 시스템]: https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

 </aside>


-## Testing CLI applications by running them
-
-Thus far, we've gone out of our way
-to test the _business logic_ of our application,
-which turned out to be the `find_matches` function.
-This is very valuable
-and is a great first step
-towards a well-tested code base.
-(Usually, these kinds of tests are called "unit tests".)
-
-There is a lot of code we aren't testing, though:
-Everything that we wrote to deal with the outside world!
-Imagine you wrote the main function,
-but accidentally left in a hard-coded string
-instead of using the argument of the user-supplied path.
-We should write tests for that, too!
-(This level of testing is often called
-"integration testing", or "system testing".)
-
-At its core,
-we are still writing functions
-and annotating them with `#[test]`.
-It's just a matter of what we do inside these functions.
-For example, we'll want to use the main binary of our project,
-and run it like a regular program.
-We will also put these tests into a new file in a new directory:
+## CLI 애플리케이션을 실행해서 테스트하기
+
+지금까지 우리는 애플리케이션의 _비즈니스 로직_ 을
+테스트하기 위해 노력했고, 주요 로직이
+`find_matches` 함수임을 알아냈습니다.
+이러한 과정은 매우 가치있으며,
+잘 테스트된(well-tested) 코드 베이스를 향한
+훌륭한 첫 걸음이기도 합니다.
+(이런 종류의 테스트를 보통 "유닛 테스트"라고 부릅니다.)
+
+그러나 바깥 세상과 상호작용하기 위해
+작성한 코드는 아직 테스트하지 않았습니다.
+만약 메인 함수를 작성했는데 실수로
+사용자가 제공하는 경로 인자 대신,
+하드 코딩된 문자열을 사용하는 코드를
+남겨뒀다고 상상해보세요.
+이에 대한 테스트도 작성해야 합니다!
+(이 수준의 테스트를 주로
+"통합 테스트" 또는 "시스템 테스트"라고 부릅니다.)
+
 `tests/cli.rs`.
+우리는 여전히 함수를 작성하고
+그 함수를 `#[test]`로 표시하고 있습니다.
+이때는 함수 안에서 무슨 일이 일어나는지만이 중요합니다.
+예를 들어, 프로젝트의 메인 바이너리를
+사용해 일반적인 프로그램처럼 실행하려 합니다.
+여러분은 이에 대한 테스트를 새로운 디렉토리에
+새 파일(`tests/cli.rs`)로 집어 넣을 것입니다:

 <aside>

-**Note:**
-By convention,
-`cargo` will look for integration tests in the `tests/` directory.
-Similarly,
-it will look for benchmarks in `benches/`,
-and examples in `examples/`.
-These conventions also extend to your main source code:
-libraries have a `src/lib.rs` file,
-the main binary is `src/main.rs`,
-or, if there are multiple binaries,
-cargo expects them to be in `src/bin/<name>.rs`.
-Following these conventions will make your code base more discoverable
-by people used to reading Rust code.
+**참고:**
+관례적으로 `cargo`는 `tests/` 디렉토리에서
+통합 테스트를 찾아봅니다.
+마찬가지로
+벤치마크는 `benches/`에서,
+예시는 `examples/`에서 찾습니다.
+이런 관례는 여러분의 주요 소스코드로도 확장됩니다.
+라이브러리는 `src/lib.rs` 파일에서,
+메인 바이너리는 `src/main.rs`에서 찾습니다.
+만약 여러 개의 바이너리가 있다면,
+cargo는 바이너리들이 `src/bin/<name>.rs`에 있을 것이라고 예상합니다.
+관례를 따르면 러스트 코드를 읽는 데 익숙한 사람들로 하여금
+여러분의 코드를 더욱 쉽게 탐색할 수 있도록 만들 수 있습니다.

 </aside>

-To recall,
-`grrs` is a small tool that searches for a string in a file.
-We have previously tested that we can find a match.
-Let's think about what other functionality we can test.
-
-Here is what I came up with.
-
-- What happens when the file doesn't exist?
-- What is the output when there is no match?
-- Does our program exit with an error when we forget one (or both) arguments?
-
-These are all valid test cases.
-Additionally,
-we should also include one test case
-for the "happy path",
-i.e., we found at least one match
-and we print it.
-
-To make these kinds of tests easier,
-we're going to use the [`assert_cmd`] crate.
-It has a bunch of neat helpers
-that allow us to run our main binary
-and see how it behaves.
-Further,
-we'll also add the [`predicates`] crate
-which helps us write assertions
-that `assert_cmd` can test against
-(and that have great error messages).
-We'll add those dependencies not to the main list,
-but to a "dev dependencies" section in our `Cargo.toml`.
-They are only required when developing the crate,
-not when using it.
+다시 돌아가서,
+`grrs`은 파일의 문자열을 찾는 작은 도구입니다.
+우리는 앞서 일치하는 문자열을 찾는 기능에 대한 테스트를 작성했습니다.
+이제 테스트할 수 있는 다른 것들에 대해 생각해봅시다.
+
+여기 몇 가지가 있습니다.
+
+- 파일이 존재하지 않을 때는 무슨 일이 일어나나요?
+- 일치하는 문자열이 없는 경우 무엇이 출력되나요?
+- 인자 하나(또는 둘 다)를 전달하지 않으면 프로그램이 에러와 함께 종료되나요?
+
+이들은 모두 유효한 테스트 케이스입니다.
+추가로,
+우리는 "행복한 경우"에 대한 테스트도 케이스도
+하나 작성해야 합니다.
+가령, 최소 하나의 일치하는 문자열을 찾고,
+그 라인을 출력하는 동작에 대한 테스트 케이스가 있습니다.
+
+이런 종류의 테스트를 쉽게 작성하기 위해,
+[`assert_cmd`] 크레이트를 사용할 것입니다.
+[`assert_cmd`]는 메인 바이너리를 실행하고,
+실행된 바이너리가 어떻게 동작하는지 보여주는
+간결한 도구들을 제공합니다.
+더 나아가,
+[`assert_cmd`]가 테스트할 어서션을
+작성할 때 도움을 받기 위하여
+(그리고 훌륭한 에러 메시지를 위하여)
+[`predicates`] 크레이트도 추가할 것입니다.
+이 두 디펜던시는 메인 리스트에 추가하지 않고
+`Cargo.toml` 파일의 "개발 디펜던시"에
+추가합니다.
+두 디펜던시가 크레이트를 개발할 때만 필요하고,
+실제로 사용할 때는 필요하지 않기 때문입니다.

 ```toml
 {{#include testing/Cargo.toml:16:18}}
@@ -420,43 +399,44 @@ not when using it.
 [`assert_cmd`]: https://docs.rs/assert_cmd
 [`predicates`]: https://docs.rs/predicates

-This sounds like a lot of setup.
-Nevertheless –
-let's dive right in
-and create our `tests/cli.rs` file:
+많은 준비가 필요해 보이죠.
+그래도 `tests/cli.rs` 파일을 만들며
+시작해 봅시다:

 ```rust,ignore
 {{#include testing/tests/cli.rs:1:15}}
 ```

-You can run this test with
-`cargo test`,
-just like the tests we wrote above.
-It might take a little longer the first time,
-as `Command::cargo_bin("grrs")` needs to compile your main binary.
-
-## Generating test files
-
-The test we've just seen only checks that our program writes an error message
-when the input file doesn't exist.
-That's an important test to have,
-but maybe not the most important one:
-Let's now test that we will actually print the matches we found in a file!
-
-We'll need to have a file whose content we know,
-so that we can know what our program _should_ return
-and check this expectation in our code.
-One idea might be to add a file to the project with custom content
-and use that in our tests.
-Another would be to create temporary files in our tests.
-For this tutorial,
-we'll have a look at the latter approach.
-Mainly, because it is more flexible and will also work in other cases;
-for example, when you are testing programs that change the files.
-
-To create these temporary files,
-we'll be using the [`assert_fs`] crate.
-Let's add it to the `dev-dependencies` in our `Cargo.toml`:
+이 테스트는 앞서 작성한 다른 테스트들과 마찬가지로
+`cargo test`로 실행할 수 있습니다.
+처음 실행할 때는 `Command::cargo_bin("grrs")`가
+메인 바이너리를 컴파일해야 하기 때문에
+시간이 조금 걸릴 수 있습니다.
+
+## 테스트 파일 생성하기
+
+앞서 작성한 테스트는 입력 파일이 존재하지 않을 때
+프로그램이 출력하는 에러 메시지만을 체크했습니다.
+이것이 중요한 테스트이기는 하지만,
+가장 중요하지는 않습니다.
+이제 파일에서 찾은 일치 문자열을 실제로 출력하는지 테스트해보겠습니다!
+
+우리가 아는 내용으로 채워진 파일이 필요합니다.
+그렇다면 우리는 프로그램이 무엇을 반환해야 하는지 예상할 수 있고,
+코드에서 그 예상을 체크할 수 있습니다.
+프로젝트에 우리가 임의의 내용으로 채운 파일을 하나 추가하고,
+이 파일을 테스트에 사용하는 방식을 생각해볼 수 있습니다.
+또 다른 방식은 테스트에서 임시 파일을 생성할 수도 있습니다.
+튜토리얼을 위해
+후자의 접근 방식을 살펴보도록 하겠습니다.
+임시 파일을 생성하는 방식은 유연하며,
+파일을 변경하는 프로그램을 테스트할 때도
+테스트가 잘 동작하도록 만들 수 있습니다.
+
+임시 파일을 만들기 위해,
+[`assert_fs`] 크레이트를 사용할 것입니다.
+`Cargo.toml` 파일의 `dev-dependencies`에
+추가해봅시다:

 ```toml
 {{#include testing/Cargo.toml:19}}
@@ -464,16 +444,13 @@ Let's add it to the `dev-dependencies` in our `Cargo.toml`:

 [`assert_fs`]: https://docs.rs/assert_fs

-Here is a new test case
-(that you can write below the other one)
-that first creates a temp file
-(a "named" one so we can get its path),
-fills it with some text,
-and then runs our program
-to see if we get the correct output.
-When the `file` goes out of scope
-(at the end of the function),
-the actual temporary file will automatically get deleted.
+아래는 임시 파일 (경로를 알 수 있도록 이름이 지정된 파일)을
+먼저 만들고 임의의 텍스트로 채운 다음,
+프로그램을 실행하여 올바를 출력을 얻을 수 있는지
+확인하는 새로운 테스트 케이스입니다.
+이 테스트 케이스를 다른 케이스 아래에 작성할 수 있습니다.
+`file`이 (함수의 끝에서) 스코프를 벗어나면,
+실제 임시 파일이 자동으로 삭제됩니다.

 ```rust,ignore
 {{#include testing/tests/cli.rs:17:32}}
@@ -481,50 +458,49 @@ the actual temporary file will automatically get deleted.

 <aside class="exercise">

-**Exercise for the reader:**
-Add integration tests for passing an empty string as pattern.
-Adjust the program as needed.
+**연습:**
+패턴으로 빈 문자열을 전달하는 경우에 대한 통합 테스트를 추가해보세요.
+필요하다면 프로그램을 수정해도 좋습니다.

 </aside>

-## What to test?
-
-While it can certainly be fun to write integration tests,
-it will also take some time to write them,
-as well as to update them when your application's behavior changes.
-To make sure you use your time wisely,
-you should ask yourself what you should test.
-
-In general it's a good idea to write integration tests
-for all types of behavior that a user can observe.
-That means that you don't need to cover all edge cases:
-It usually suffices to have examples for the different types
-and rely on unit tests to cover the edge cases.
-
-It is also a good idea not to focus your tests on things you can't actively control.
-It would be a bad idea to test the exact layout of `--help`
-as it is generated for you.
-Instead, you might just want to check that certain elements are present.
-
-Depending on the nature of your program,
-you can also try to add more testing techniques.
-For example,
-if you have extracted parts of your program
-and find yourself writing a lot of example cases as unit tests
-while trying to come up with all the edge cases,
-you should look into [`proptest`].
-If you have a program which consumes arbitrary files and parses them,
-try to write a [fuzzer] to find bugs in edge cases.
+## 무엇을 테스트할 것인가?
+
+통합 테스트를 작성하는 것이 분명 재밌을 수도 있지만,
+테스트를 작성하는 데 드는 시간이
+애플리케이션의 동작을 변경할 때만큼 필요할 수도 있습니다.
+시간을 현명하게 사용하기 위해서는
+스스로에게 무엇을 테스트해야 하는지 물어야 합니다.
+
+사용자에게 노출되는 모든 종류의 행동에 대한
+통합 테스트를 작성하는 것이 일반적으로 좋은 생각이기는 합니다.
+다만 모든 엣지 케이스를 커버할 필요는 없습니다.
+보통 다양한 유형에 대한 예시를 만드는 것으로 충분하며,
+엣지 케이스는 유닛 테스트에 맡기면 됩니다.
+
+여러분이 적극적으로 통제할 수 없는 것에 대해 테스트를 집중하지 않는 것도 좋은 생각입니다.
+`--help`가 출력하는 세세한 내용을 테스트하는 것은 좋은 생각이 아닙니다.
+대신 특정 요소가 노출되는지만 테스트하는 것이 좋습니다.
+
+프로그램의 특성에 따라,
+더 많은 테스트 기법을 추가해볼 수도 있습니다.
+예를 들어,
+프로그램의 일부를 추출해
+모든 엣지 케이스를 찾아내려고 애쓰는 동시에
+유닛 테스트로 많은 양의 예시 케이스를 작성하고 있는
+자신을 발견한다면, [`proptest`]를 살펴봐야 합니다.
+만약 임의의 파일을 사용하고, 그 파일을 파싱하는 프로그램을 만든다면
+엣지 케이스에서 버그를 찾기 위해 [fuzzer]를 사용해볼 수 있습니다.

 [`proptest`]: https://docs.rs/proptest
 [fuzzer]: https://rust-fuzz.github.io/book/introduction.html

 <aside>

-**Note:**
-You can find the full, runnable source code used in this chapter
-[in this book's repository][src].
+**참고:**
+이 챕터에서 사용된 전체 코드는 [이 책의 저장소][src]에서
+찾아볼 수 있습니다.

-[src]: https://github.com/rust-cli/book/tree/master/src/tutorial/testing
+[src]: https://github.com/parksb/rust-cli-book-ko-kr/tree/master/src/tutorial/testing

 </aside>
diff --git a/src/tutorial/testing/src/main.rs b/src/tutorial/testing/src/main.rs
index 486a523..4ddb7b2 100644
--- a/src/tutorial/testing/src/main.rs
+++ b/src/tutorial/testing/src/main.rs
@@ -1,12 +1,12 @@
 use anyhow::{Context, Result};
 use clap::Parser;

-/// Search for a pattern in a file and display the lines that contain it.
+/// 파일에서 패턴을 찾고 패턴을 포함한 라인을 보여준다.
 #[derive(Parser)]
 struct Cli {
-    /// The pattern to look for
+    /// 찾을 패턴
     pattern: String,
-    /// The path to the file to read
+    /// 읽을 파일 경로
     path: std::path::PathBuf,
 }

diff --git a/src/tutorial/testing/tests/cli.rs b/src/tutorial/testing/tests/cli.rs
index 5bfed30..2666887 100644
--- a/src/tutorial/testing/tests/cli.rs
+++ b/src/tutorial/testing/tests/cli.rs
@@ -1,6 +1,6 @@
-use assert_cmd::prelude::*; // Add methods on commands
-use predicates::prelude::*; // Used for writing assertions
-use std::process::Command; // Run programs
+use assert_cmd::prelude::*; // 명령에 메서드 추가
+use predicates::prelude::*; // 어서션 작성에 사용
+use std::process::Command; // 프로그램을 실행

 #[test]
 fn file_doesnt_exist() -> Result<(), Box<dyn std::error::Error>> {
